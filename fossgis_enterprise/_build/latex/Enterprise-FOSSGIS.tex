%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{Enterprise FOSS-GIS}
\date{Dec 09, 2020}
\release{}
\author{Dany Laksono}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxstylestrong{Tentang Panduan ini}

Panduan ini dibuat untuk memberikan pengantar dalam penggunaan perangkat lunak OpenSource untuk Enterprise GIS. Panduan ini memberikan dasar yang diperlukan untuk mengenal dan menggunakan beberapa aplikasi GIS yang bersifat bebas dan terbuka, dengan Linux sebagai sistem operasi utamanya.

Panduan ini dapat diberikan sebagai pegangan pada pelatihan maupun sebagai bahan untuk \sphinxstyleemphasis{self\sphinxhyphen{}paced learning}. Modul ini dilengkapi berbagai latihan yang diberikan untuk mendukung pemahaman tiap materi yang disampaikan.

\sphinxstylestrong{Jadwal Pelatihan}

Apabila diberikan pada sesi pelatihan tentang Free and OpenSource GIS, pembagian jadwal dari materi ini dapat dilakukan sebagai berikut:

\sphinxstyleemphasis{Hari 1: Linux Server dan FOSS4G}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Waktu
&\sphinxstyletheadfamily 
Materi Pelatihan
\\
\hline
09.00 \sphinxhyphen{} 10.00
&
Pendahuluan, Instalasi Linux VM
\\
\hline
10.00 \sphinxhyphen{} 10.15
&
\sphinxstyleemphasis{Break}
\\
\hline
10.15 \sphinxhyphen{} 12.00
&
Arsitektur dan Administrasi Sistem Ubuntu Linux
\\
\hline
12.00 \sphinxhyphen{} 13.00
&
\sphinxstyleemphasis{ISHOMA}
\\
\hline
13.00 \sphinxhyphen{} 15.00
&
Linux untuk Server Web
\\
\hline
15.00 \sphinxhyphen{} 15.15
&
\sphinxstyleemphasis{Break}
\\
\hline
15.15 \sphinxhyphen{} 16.00
&
Pengantar Free and OpenSource GIS (FOSS\sphinxhyphen{}GIS)
\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstyleemphasis{Hari 2: Relational Spatial Database}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Waktu
&\sphinxstyletheadfamily 
Materi Pelatihan
\\
\hline
09.00 \sphinxhyphen{} 10.00
&
Konsep Relational DatabasePengaturan dan Instalasi Basisdata
\\
\hline
10.00 \sphinxhyphen{} 10.15
&
\sphinxstyleemphasis{Break}
\\
\hline
10.15 \sphinxhyphen{} 12.00
&
Adminsitrasi Enterprise GIS dengan PostGIS: User, Roles, Priviledges
\\
\hline
12.00 \sphinxhyphen{} 13.00
&
\sphinxstyleemphasis{ISHOMA}
\\
\hline
13.00 \sphinxhyphen{} 15.00
&
Bekerja dengan PostGIS
\\
\hline
15.00 \sphinxhyphen{} 15.15
&
\sphinxstyleemphasis{Break}
\\
\hline
15.15 \sphinxhyphen{} 16.00
&
SQL vs NoSQL Database
\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstyleemphasis{Hari 3: Standar OGC untuk Interoperabilitas Data Spasial}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Waktu
&\sphinxstyletheadfamily 
Materi Pelatihan
\\
\hline
09.00 \sphinxhyphen{} 10.00
&
Interoperabilitas dan Standar OGC  Instalasi dan Pengaturan Geoserver
\\
\hline
10.00 \sphinxhyphen{} 10.15
&
\sphinxstyleemphasis{Break}
\\
\hline
10.15 \sphinxhyphen{} 12.00
&
Publikasi data dengan standar OGC pada Geoserver
\\
\hline
12.00 \sphinxhyphen{} 13.00
&
\sphinxstyleemphasis{ISHOMA}
\\
\hline
13.00 \sphinxhyphen{} 15.00
&
Pengaturan dan konsumsi data melalui layanan OGC
\\
\hline
15.00 \sphinxhyphen{} 15.15
&
\sphinxstyleemphasis{Break}
\\
\hline
15.15 \sphinxhyphen{} 16.00
&
Arsitektur Enterprise GIS dengan FOSS4G
\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Lisensi Dokumen}

Dokumen ini dan latihan yang ada di dalamnya disusun di bawah panduan \sphinxhref{https://creativecommons.org/licenses/by-sa/4.0/}{CC\sphinxhyphen{}BY\sphinxhyphen{}SA versi 4.0}.

Dokumen ini ditulis oleh \sphinxhref{https://www.danylaksono.com/}{Dany Laksono} untuk Pusat Data dan Teknologi Informasi (Pusdatin) Kementerian PUPR tahun 2020

\sphinxstylestrong{Lisensi Perangkat Lunak}

Seluruh perangkat lunak yang digunakan maupun diacu pada modul ini memiliki lisensi bebas dan terbuka (Free and Open Source). Lisensi masing\sphinxhyphen{}masing perangkat lunak dapat dilihat pada penjelasan lebih rinci mengenai software tersebut


\chapter{Pengantar Linux Server, FOSS\sphinxhyphen{}GIS dan Web Server}
\label{\detokenize{sesi1/introlinux:pengantar-linux-server-foss-gis-dan-web-server}}\label{\detokenize{sesi1/introlinux::doc}}
Linux, atau GNU/Linux, mengacu pada sistem operasi komputer Unix\sphinxhyphen{}like yang menggunakan kernel Linux. Linux merupakan contoh paling menonjol dari pengembangan open source dan perangkat lunak bebas serta perangkat lunak yang dibuat pengguna; kode sumber yang mendasarinya tersedia bagi siapa saja untuk digunakan, dimodifikasi, dan didistribusikan kembali secara bebas.

Bagian ini merupakan bagian pertama dari panduan ini. Sesi ini membahas mengenai Linux dan cara kerjanya, serta bagaimana Linux digunakan sebagai sistem operasi untuk menunjang penggunaan \sphinxstyleemphasis{Free and Open Source Software (FOSS)}, khususnya untuk menunjang analisis dan manajemen data Geospasial.

Berikut adalah materi yang dibahas pada bagian ini:

 {\hyperref[\detokenize{sesi1/pengantarlinux::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Pengantar mengenai Linux}}}}
: Sejarah dan perkembangan Linux, beberapa Distro Linux yang terkenal, serta instalasi dan penggunaan Ubuntu Linux, yang akan digunakan pada seluruh dokumen latihan ini.

 {\hyperref[\detokenize{sesi1/arsitektur::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Arsitektur dan Administrasi sistem Linux}}}}
: Beberapa konsep tentang arsitektur Linux sebagai sebuah sistem operasi, serta bagaimana pengaturan Linux pada sebuah lingkungan server

 {\hyperref[\detokenize{sesi1/linuxserver::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Linux untuk Webserver}}}}
: Latihan mengenai pengaturan Linux untuk publikasi halaman web dengan menggunakan Apache/httpd dan Tomcat. Akan disampaikan juga mengenai penggunaan Virtual Host dan konsep proxy pada Apache untuk keperluan publikasi website

 {\hyperref[\detokenize{sesi1/fossgis::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Pengantar FOSS\sphinxhyphen{}GIS}}}}
: Mengenal jenis\sphinxhyphen{}jenis lisensi perangkat lunak serta beberapa perangkat FOSS\sphinxhyphen{}GIS yang populer.


\section{Pengantar Linux dan Server}
\label{\detokenize{sesi1/pengantarlinux:pengantar-linux-dan-server}}\label{\detokenize{sesi1/pengantarlinux::doc}}
Bagian ini akan mengulas mengenai sejarah perkembangan Linux dan bagaimana Linux menjadi salah satu sistem operasi yang paling banyak digunakan dan paling pesat perkembangannya di dunia: \sphinxstylestrong{Lisensi yang bebas dan terbuka}.


\subsection{Sejarah dan Perkembangan Sistem Operasi Linux}
\label{\detokenize{sesi1/pengantarlinux:sejarah-dan-perkembangan-sistem-operasi-linux}}
Pada tanggal 25 Agustus 1991, \sphinxhref{https://github.com/torvalds}{Linus Benedict Torvalds} yang saat itu adalah seorang mahasiswa di University of Helsinky menulis sebuah email yang kemudian menjadi \sphinxstyleemphasis{ikon} di dunia pengembangan perangkat lunak:
\begin{quote}

Hello everybody out there using minix \sphinxhyphen{}
\end{quote}

Email sederhana ini, dengan sedikit penjelasan mengenai sistem operasi baru yang sedang ia kembangkan, kemudian menjadi awal dari adopsi besar\sphinxhyphen{}besaran Linux sampai menjadi sistem operasi yang sangat populer saat ini.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=500\sphinxpxdimen]{{2020-12-01-22-47-51}.png}
\caption{Email bersejarah Linus pada forum \sphinxstyleemphasis{com.os.minix}}\label{\detokenize{sesi1/pengantarlinux:linus-email}}\end{figure}

Meskipun diakhiri dengan nada pesimis, Kernel Linux yang dikembangkannya menjadi salah satu \sphinxstyleemphasis{milestone} dalam sejarah komputer. Dari kernel sederhana yang menurutnya ‘hanya dapat digunakan pada mesin AT\sphinxhyphen{}386’, Linux kemudian berkembang menjadi sistem operasi yang dapat digunakan pada berbagai platform: super komputer, server, \sphinxstyleemphasis{embedded device}, dan berbagai platform lain.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-01-23-05-51}.png}
\caption{Sejarah perkembangan Linux}\label{\detokenize{sesi1/pengantarlinux:sejarah-linux}}\end{figure}

Lisensi yang terbuka (\sphinxhref{https://www.gnu.org/licenses/gpl-3.0.en.html}{GNU General Public License} yang dikembangkan oleh \sphinxhref{https://stallman.org/}{Richard Stallman}) memungkinkan Linux untuk dikembangkan secara bebas: tiap orang dapat membuat versi Linux mereka sendiri, membuat \sphinxstyleemphasis{copy}, melakukan modifikasi pada kode sumber, serta membagikan modifikasi tersebut dengan satu syarat, yaitu setiap perubahan tersebut dibuat dalam lisensi publik yang terbuka. Penggunaan lisensi ini penting dalam perkembangan Linux kemudian, sehingga bermunculan berbagai macam distribusi Linux yang menyesuaikan berbagai platform dan kebutuhan penggunanya.


\subsection{Distribusi Linux}
\label{\detokenize{sesi1/pengantarlinux:distribusi-linux}}
\sphinxstyleemphasis{Linux Distribution} (disingkat \sphinxstyleemphasis{Distro}) merupakan sistem operasi yang menggunakan Kernel Linux sebagai basisnya, dengan berbagai komponen lain yang berbeda\sphinxhyphen{}beda, seperti \sphinxstyleemphasis{Desktop Environment, package management system,} berbagai pustaka tambahan, dan seterusnya.

Meskipun menggunakan kernel Linux yang sama, dengan sifatnya yang bebas dan terbuka, berbagai distro ini kemudian memiliki komponen yang beragam sehingga muncul berbagai variasi \sphinxhref{https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux\_Distribution\_Timeline.svg}{distro Linux yang tersedia saat ini}. Saat dokumen ini ditulis, tidak kurang terdapat 600 distro Linux yang berbeda, dengan 500 diantaranya masih dalam tahap \sphinxstyleemphasis{development} aktif.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-01-23-31-58}.png}
\caption{Timeline Distribusi Linux. Klik \sphinxhref{https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux\_Distribution\_Timeline.svg}{di sini} untuk melihat versi interaktifnya}\label{\detokenize{sesi1/pengantarlinux:distro-linux}}\end{figure}

Beberapa distro Linux yang populer antara lain %
\begin{footnote}[1]\sphinxAtStartFootnote
https://www.techradar.com/best/best\sphinxhyphen{}linux\sphinxhyphen{}distros
%
\end{footnote}:


\subsubsection{Ubuntu}
\label{\detokenize{sesi1/pengantarlinux:ubuntu}}
\sphinxhref{https://ubuntu.com/}{Ubuntu} merupakan salah satu sistem operasi Linux yang paling populer saat ini. Ubuntu dilengkapi dengan package management (\sphinxstyleemphasis{Advanced Package Tool} atau \sphinxstyleemphasis{apt}) dan \sphinxstyleemphasis{destop environment} berbasis GNOME yang mendukung kemudahan penggunaannya untuk pemula. Ubuntu didukung dengan stabilitas dan keamanan yang mumpuni dengan versi LTS (\sphinxstyleemphasis{Long Term Support}) yang dirilis secara berkala oleh Canonical sebagai developer sistem operasi ini. Atas alasan itulah Ubuntu juga menjadi salah satu sistem operasi yang banyak dijumpai pada server. Ini juga didukung oleh adanya \sphinxstyleemphasis{community support} yang besar dan aktif, serta dukungan berbagai perangkat lunak pihak ketiga pada sistemnya.

\sphinxincludegraphics{{2020-12-01-23-47-59}.png}

Saat ini, versi Long Term Support untuk Ubuntu adalah 20.04 (Focal Fossa). Selain versi ini, versi LTS sebelumnya adalah 18.04 (Bionic Beaver) dan 16.04 (Xenial Xerus). Untuk penggunaan pada modul ini, akan digunakan Ubuntu versi LTS 18.04, untuk mengantisipasi adanya beberapa package yang belum didukung pada versi LTS terbaru. Pada prakteknya, penggunaan versi LTS yang lebih baru akan lebih baik, karena adanya dukungan keamanan dan \sphinxstyleemphasis{patch} yang diberikan pada tiap versi terbarunya.


\subsubsection{CentOS}
\label{\detokenize{sesi1/pengantarlinux:centos}}
\sphinxhref{https://www.centos.org/}{CentOS} merupakan pengembangan dari RedHat Linux yang banyak digunakan untuk komputer pada server maupun komputasi awan. Sebagai sebuah sistem operasi desktop, CentOS juga dilengkapi dengan antarmuka berbasis GNOME, sama seperti Ubuntu. CentOS dikenal karena menyediakan fungsi Enterprise sebagai sebuah sistem operasi pada server tanpa perlu mengeluarkan biaya sepeser pun.

\sphinxincludegraphics{{2020-12-02-00-10-11}.png}


\subsubsection{Linuxmint}
\label{\detokenize{sesi1/pengantarlinux:linuxmint}}
Bagi pengguna yang baru saja ingin migrasi dari Windows dan mencoba antarmuka Linux Desktop, \sphinxhref{https://www.centos.org/}{Linuxmint} merupakan pilihan yang sesuai. Desain antarmukanya dibuat sedemikian rupa untuk memudahkan pengguna pemula yang ingin mencoba Linux.
\sphinxincludegraphics{{2020-12-02-00-08-54}.png}


\subsubsection{ArchLinux}
\label{\detokenize{sesi1/pengantarlinux:archlinux}}
Untuk pengguna yang menginginkan kebebasan kustomisasi tanpa mengorbankan antarmuka berbasis desktop, \sphinxhref{https://www.archlinux.org/}{ArchLinux} dapat menjadi pilihan yang sesuai. ArchLinux memiliki konsep ringan (\sphinxstyleemphasis{lightweight}), dengan komponen desktop environment yang kaya pilihan: Cinnamon, Enlightenment, GNOME, KDE, LXDE, MATE, Xfce.

\sphinxincludegraphics{{2020-12-02-00-08-08}.png}


\subsubsection{Elemetary OS}
\label{\detokenize{sesi1/pengantarlinux:elemetary-os}}
Selain LinuxMint, \sphinxhref{https://elementary.io/}{ElementaryOS} dikenal sebagai sistem operasi dengan tampilan yang paling memukau. Sistem Operasi ini didesain dengan tampilan yang, bagi pengguna Mac maupun Windows, akan terasa familiar. ElementaryOS dikembangkan dari sistem operasi Ubuntu LTS, dan membanggakan kebijakan penjagaan privasi yang kuat untuk penggunanya.

\sphinxincludegraphics{{2020-12-02-00-11-43}.png}


\subsubsection{Kali Linux}
\label{\detokenize{sesi1/pengantarlinux:kali-linux}}
Barangkali \sphinxhref{https://www.kali.org/}{Kali Linux} merupakan sistem operasi yang paling dikenal di kalangan Hacker. Kali Linux merupakan sistem operasi Linux yang dirancang khusus untuk keperluan \sphinxstyleemphasis{penetration testing} atau pengujian keamanan suatu sistem atau perangkat lunak. Instalasi standar Kali Linux dilengkapi dengan \sphinxhref{https://tools.kali.org/}{berbagai perangkat} yang dapat digunakan untuk melakukan \sphinxstyleemphasis{pentesting}, seperti \sphinxcode{\sphinxupquote{aircrack\sphinxhyphen{}ng}} dan \sphinxcode{\sphinxupquote{Wireshark}}. Kali Linux bahkan juga dilengkapi dengan PowerShell bagi pengguna yang menginginkan lingkungan scripting tersebut pada Linux.

\sphinxincludegraphics{{2020-12-02-00-11-06}.png}

Selain berbagai distro yang disebutkan di atas, terdapat ratusan distro lain yang digunakan untuk berbagai keperluan. Tiap distro memiliki keunggulan masing\sphinxhyphen{}masing, sehingga daftar ini terlalu pendek untuk sebuah ulasan lengkap. \sphinxhref{https://distrowatch.com/}{Situs ini} menyediakan perbandingan untuk tiap distro yang terdaftar berikut ulasan singkat mengenai masing\sphinxhyphen{}masing distro.


\subsection{Windows Subsystem for Linux}
\label{\detokenize{sesi1/pengantarlinux:windows-subsystem-for-linux}}
Dengan perkembangan pesat Linux pada berbagai platform dan dukungan komunitas yang sangat besar, Linux menjadi sistem operasi yang banyak digunakan oleh pengembang aplikasi, khususnya pada penggunaan server. Linux banyak digunakan karena selain mudah, keamanan dan stabilitas sistem yang diberikan juga menjadi poin penting dalam penggunaannya untuk keperluan server. Di sisi lain, Windows sebagai sistem operasi yang paling populer saat ini juga banyak digunakan untuk keperluan sehari\sphinxhyphen{}hari. Untuk itu, pengembangan perangkat lunak seringkali melibatkan kedua sistem operasi ini sekaligus (juga MacOS, bagi pengguna setianya). Pada bagian ini akan dibahas mengenai WSL versi 2 sebagai jembatan untuk Windows dan Linux yang akan sangat membantu pengembang dalam menggunakan Linux pada Sistem Operasi Windows.


\subsubsection{Tentang Windows Subsystem for Linux (WSL)}
\label{\detokenize{sesi1/pengantarlinux:tentang-windows-subsystem-for-linux-wsl}}
Pada tahun 2017, Microsoft sebagai pesaing terbesar Linux membuat pengumuman yang mengejutkan: Windows 10 sebagai sistem operasi utama Windows pada saat ini akan memiliki dukungan untuk menjalankan Linux Kernel secara \sphinxstyleemphasis{native}. Sebelumnya, bagi \sphinxstyleemphasis{developer} yang ingin menggunakan Windows dan Linux secara bersamaan harus menggunakan perangkat virtualisasi (misalnya Vagrant) atau melakukan instalasi dual\sphinxhyphen{}boot agar kedua sistem dapat berjalan. Penggunaan WSL memungkinkan Linux untuk dapat dijalankan dengan ringan pada sistem operasi Windows.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-02-00-35-17}.png}
\caption{WSL memungkinkan Linux dijalankan pada Windows}\label{\detokenize{sesi1/pengantarlinux:wsl}}\end{figure}

WSL2 (Windows Subsystem for Linux 2) merupakan integrasi mesin berbasis Linux pada Windows yang memungkinkan mesin Linux untuk dapat dijalankan pada Windows dengan performa maksimal. Indeks angka “2” menunjukkan bahwa virtualisasi ini adalah pengembangan lebih jauh dari mesin WSL yang pertama kali diusulkan oleh Microsoft pada tahun 2017. Perbedaan mencolok terlihat karena pada WSL2, mesin virtual yang dipasang menggunakan kernel linux yang sebenarnya. Artinya, performa yang dapat diperoleh dari mesin virtual ini juga sebaik mesin Linux dengan kekuatan penuh. Selain itu, dengan menggunakan \sphinxhref{https://ubuntu.com/wsl}{Distro yang didukung oleh WSL2}, akses Windows pada mesin (dan sebaliknya) dapat dilakukan secara hampir \sphinxstyleemphasis{seamless}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{image-20201129191425719}.png}
\caption{Ubuntu yang khusus dirancang untuk WSL}\label{\detokenize{sesi1/pengantarlinux:wsl2}}\end{figure}


\subsubsection{Latihan: Instalasi WSL2 Pada Windows 10}
\label{\detokenize{sesi1/pengantarlinux:latihan-instalasi-wsl2-pada-windows-10}}
Untuk instalasi WSL2 ini, berikut adalah persyaratan yang harus dipenuhi:
\begin{itemize}
\item {} 
Windows 10 dengan versi update terbaru: Windows 10 May 2020 (2004), Windows 10 May 2019 (1903), or Windows 10 November 2019 (1909). Windows dengan versi update lama (1903 atau 1909) tetap dapat menginstall WSL2 dengan terlebih dahulu melakukan instalasi Windows Update \sphinxhref{https://support.microsoft.com/en-us/help/4566116/windows-10-update-kb4566116}{berikut ini}

\item {} 
Komputer atau laptop yang memiliki dukungan \sphinxstylestrong{Hyper\sphinxhyphen{}V Virtualization}. Periksa \sphinxhref{https://www.zdnet.com/article/windows-10-tip-find-out-if-your-pc-can-run-hyper-v/}{link berikut} untuk mengetahui apakah Komputer atau laptop Anda memiliki dukungan Hyper\sphinxhyphen{}V.

\end{itemize}

Untuk melihat versi build Windows yang Anda gunakan, lakukan langkah berikut:
\begin{itemize}
\item {} 
Buka Windows Run (Win+R)

\item {} 
Ketikkan \sphinxcode{\sphinxupquote{'winver'}}

\item {} 
Pada jendela yang muncul, akan terlihat versi build Windows yang sedang berjalan

\sphinxincludegraphics{{2020-12-02-00-26-50}.png}

Apabila versi build Windows Anda di bawah \sphinxcode{\sphinxupquote{18362}}, maka terlebih dulu lakukan update Windows menggunakan \sphinxhref{https://www.microsoft.com/software-download/windows10}{Update Assistant}.

Jika Hyper\sphinxhyphen{}V belum diaktifkan pada firmware, maka opsi ini perlu diaktifkan terlebih dulu pada BIOS. \sphinxhref{https://techcommunity.microsoft.com/t5/itops-talk-blog/step-by-step-enabling-hyper-v-for-use-on-windows-10/ba-p/267945}{Panduan ini} menyediakan langkah yang diperlukan untuk mengaktifkan Hyper\sphinxhyphen{}V pada BIOS dan pada Windows 10.

\end{itemize}
\begin{quote}

\sphinxstylestrong{Catatan:}

Panduan ini dibuat dengan mengikuti panduan resmi di:

https://docs.microsoft.com/en\sphinxhyphen{}us/windows/wsl/install\sphinxhyphen{}win10

Periksa tautan tersebut untuk melihat perubahan terbaru terkait dengan instalasi WSL
\end{quote}

Berikut adalah petunjuk untuk melakukan instalasi WSL2 pada Sistem Operasi Windows 10:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstyleemphasis{Mengaktifkan WSL melalui PowerShell}

Buka \sphinxcode{\sphinxupquote{Windows PowerShell}} sebagai Administrator.

\sphinxincludegraphics{{2020-12-02-00-27-16}.png}

Ketikkan perintah berikut pada command prompt yang tersedia:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dism.exe /online /enable\PYGZhy{}feature /featurename:Microsoft\PYGZhy{}Windows\PYGZhy{}Subsystem\PYGZhy{}Linux /all /norestart
\end{sphinxVerbatim}

Akan muncul pemberitahuan apabila proses telah berhasil:

\sphinxincludegraphics{{2020-12-02-00-27-37}.png}

 

\item {} 
\sphinxstyleemphasis{Update ke WSL versi 2}

Pastikan versi build Windows yang digunakan sesuai untuk persyaratan WSL2 seperti di atas. Periksa \sphinxhref{https://docs.microsoft.com/en-us/windows/wsl/install-win10\#step-2---update-to-wsl-2}{link berikut} untuk melihat lebih detil mengenai bagian ini.

 

\item {} 
\sphinxstyleemphasis{Aktifkan Virtual Machine Platform}

Pada jendela PowerShell yang sama (sebagai Administrator), ketikkan perintah berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dism.exe /online /enable\PYGZhy{}feature /featurename:VirtualMachinePlatform /all /norestart
\end{sphinxVerbatim}

Setelah perintah selesai dijalankan, lakukan \sphinxstylestrong{restart pada Windows}. Ini akan mengupdate WSL pada system menjadi versi ke\sphinxhyphen{}2

 

\begin{sphinxadmonition}{caution}{Caution:}
Restart Windows penting dalam hal ini agar sistem WSL terupdate pada versi terbaru.
\end{sphinxadmonition}

 

\item {} 
\sphinxstyleemphasis{Unduh Linux kernel untuk WSL2}

Terlebih dahulu unduh dan install Linux Kernel untuk WSL2 dari \sphinxhref{https://wslstorestorage.blob.core.windows.net/wslblob/wsl\_update\_x64.msi}{Link Berikut}.

Setelah instalasi berhasil, masukkan perintah berikut ke dalam PowerShell yang sama seperti sebelumnya:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
wsl \PYGZhy{}\PYGZhy{}set\PYGZhy{}default\PYGZhy{}version \PYG{l+m}{2}
\end{sphinxVerbatim}

Ini akan membuat versi WSL yang telah terinstall menggunakan versi kedua.

 

\item {} 
\sphinxstyleemphasis{Melakukan Instalasi Distro Linux}

Pada \sphinxhref{https://aka.ms/wslstore}{Microsoft Store} telah tersedia beberapa distro Linux yang dapat digunakan pada WSL. Buka Microsoft Store, kemudian lakukan instalasi untuk distro yang dipilih. Untuk latihan ini, gunakan \sphinxcode{\sphinxupquote{Ubuntu}}, khususnya versi \sphinxhref{https://www.microsoft.com/store/apps/9N9TNGVNDL3Q}{Ubuntu 18.04}.

\sphinxincludegraphics{{2020-12-02-00-28-08}.png}

 Klik \sphinxcode{\sphinxupquote{Get}} untuk melakukan instalasi Ubuntu pada WSL2

 \sphinxincludegraphics{{2020-12-02-00-28-23}.png}

 

\item {} 
\sphinxstyleemphasis{Memulai WSL}

Setelah instalasi selesai, Ubuntu dapat langsung digunakan pada Windows. Untuk memulai WSL, buka icon menu bergambar logo Ubuntu pada Start Menu.

Pada saat pertama kali dibuka, mesin akan meminta \sphinxstylestrong{username} dan \sphinxstylestrong{password}. Catat username dan password yang dimasukkan karena ini akan menjadi akun \sphinxstyleemphasis{sudoer}  pada mesin Linux yang dibuat.

\sphinxincludegraphics{{2020-12-02-00-29-10}.png}

Selanjutnya, Ubuntu siap digunakan

\sphinxincludegraphics{{2020-12-02-00-29-18}.png}

 

\item {} 
\sphinxstyleemphasis{Integrasi WSL dan Windows}

Telah disampaikan sebelumnya bahwa integrasi Linux dan Windows menggunakan WSL2 bersifat hampir seamless. Artinya, kedua sistem dapat saling berkomunikasi tanpa memerlukan media perantara yang rumit.

Untuk mengakses file WSL dari windows, buka Explorer, kemudian ketikkan pada bagian directory list: \sphinxcode{\sphinxupquote{\textbackslash{}\textbackslash{}wsl\$}}.

\sphinxincludegraphics{{2020-12-02-00-29-29}.png}

Maka Windows akan membuka drive pada Linux sebagaimana sebuah folder biasa pada Explorer.

\sphinxincludegraphics{{2020-12-02-00-29-36}.png}

Berkas yang disimpan pada ‘folder’ ini akan langsung terintegrasi dengan Linux tanpa perlu melakukan \sphinxstyleemphasis{rebooting}.

Demikian pula, pada saat Ubuntu memanggil port tertentu, maka WSL akan secara otomatis melakukan \sphinxstyleemphasis{port forwarding}, sehingga port tersebut dapat dibuka pada Windows tanpa perlu melakukan langkah tambahan apapun.

Sebagai contoh, berikut adalah pemanggilan Jupyter Lab dari konsol Ubuntu pada WSL2:

\sphinxincludegraphics{{2020-12-02-00-29-45}.png}

Dan berikut adalah tampilan Jupyter Lab apabila dibuka pada browser di Windows:

\sphinxincludegraphics{{2020-12-02-00-29-53}.png}

 

\item {} 
\sphinxstyleemphasis{WSL2 untuk keperluan pembangunan aplikasi (development)}

Untuk keperluan pembangunan aplikasi, WSL2 memungkinkan koneksi pada beberapa Code Editor. Sebagai contoh, VSCode memiliki dukungan untuk melakukan \sphinxstyleemphasis{editing} kode pada WSL2 melalui plugin. Klik \sphinxhref{https://code.visualstudio.com/docs/remote/wsl}{Link berikut} untuk detilnya.

\sphinxincludegraphics{{2020-12-02-00-30-07}.png}

Berikut adalah contoh pemanggilan VSCode dari mesin Ubuntu:

\sphinxincludegraphics{{2020-12-02-00-30-17}.png}



dan berikut adalah tampilan dari VSCode yang langsung terbuka dan terkoneksi dengan WSL2 tersebut:



\sphinxincludegraphics{{2020-12-02-00-30-27}.png}

\end{enumerate}

 

Karena pengaturan \sphinxstyleemphasis{resource} untuk komputasi (memory, space harddisk) dilakukan \sphinxhref{https://www.digitalocean.com/community/posts/trying-the-new-wsl-2-its-fast-windows-subsystem-for-linux}{secara bersama\sphinxhyphen{}sama} oleh Windows dan WSL2 melalui Linux Kernel, maka penggunaan WSL tidak akan membebani sistem Windows. Dengan demikian, penggunaan Linux pada WSL2 ini adalah metode yang lebih disarankan daripada menggunakan Virtual Machine seperti VirtualBox atau VMWare yang dapat membebani kinerja sistem.

Hasil dari latihan di atas adalah WSL2 dengan Ubuntu sebagai sistem operasi yang dapat digunakan pada Windows. Selain diinstall sebagai WSL yang dapat diakses pada sistem lokal, terdapat beberapa opsi lain yang daat dilakukan untuk menggunakan Linux. \sphinxhref{https://www.danylaksono.com/docs/linuxvm/}{Link berikut} memberikan panduan ringkas mengenai bagaimana melakukan instalasi Linux baik pada Cloud maupun lokal.


\bigskip\hrule\bigskip



\section{Pengaturan dan Administrasi Linux}
\label{\detokenize{sesi1/arsitektur:pengaturan-dan-administrasi-linux}}\label{\detokenize{sesi1/arsitektur::doc}}
Setelah memiliki sebuah sistem operasi Linux yang dapat digunakan untuk latihan dengan menggunakan WSL, pada bagian ini akan dibahas mengenai beberapa perintah dasar pada Linux.

\begin{sphinxadmonition}{note}{Catatan}

\sphinxstylestrong{Ubuntu Pocket Guide} merupakan panduan yang cukup komprehensive untuk ‘penggunaan Ubuntu sehari\sphinxhyphen{}hari’. Buku ini dapat diunduh secara gratis dari alamat: \sphinxurl{http://www.ubuntupocketguide.com/download\_main.html}
\end{sphinxadmonition}


\subsection{Arsitektur Linux}
\label{\detokenize{sesi1/arsitektur:arsitektur-linux}}
Sebelum terjun langsung dalam penggunaan Linux, sebaiknya terlebih dahulu dipelajari mengenai filosofi dan arsitektur sebuah sistem operasi Linux. Pemahaman mengenai hal ini akan memudahkan dalam bekerja dengan Linux serta menghindari permasalahan pada saat bekerja dengan Linux.


\subsubsection{Kernel dan komponen\sphinxhyphen{}komponen Linux}
\label{\detokenize{sesi1/arsitektur:kernel-dan-komponen-komponen-linux}}
Sebelumnya, {\hyperref[\detokenize{sesi1/arsitektur:kernel}]{\sphinxcrossref{\DUrole{std,std-ref}{kernel linux}}}} telah disebutkan beberapa kali pada panduan ini. Lisensi kernel Linux yang dikembangkan oleh Linus Torvalds sebagai rangkaian kode yang bersifat bebas dan terbuka memungkinkan pengembangan berbagai aplikasi lain di atasnya, yang kemudian melahirkan ratusan distro yang masing\sphinxhyphen{}masingnya adalah sebuah sistem operasi sendiri. Tetapi, apa sebenarnya yang dimaksud dengan \sphinxstyleemphasis{Linux Kernel}?

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-02-02-49-33}.png}
\caption{Arsitektur Sistem Operasi Linux}\label{\detokenize{sesi1/arsitektur:kernel}}\end{figure}

Sebuah ‘kernel’ dapat diartikan sebagai potongan kode yang menjadi antarmuka antara perangkat keras (\sphinxstyleemphasis{hardware}) dan berbagai aplikasi yang menggunakan perangkat tersebut. Linux Kernel yang awalnya didesain oleh Linus Torvalds sebagai sebuah sistem yang tertutup dan tidak portabel ternyata berubah menjadi kode yang dapat digunakan pada berbagai platform dengan dukungan pada berbagai perangkat keras, sehingga muncul berbagai pengembangan versi distribusi Linux yang berbeda.


\subsubsection{Filosofi Linux}
\label{\detokenize{sesi1/arsitektur:filosofi-linux}}
Di atas kernel inilah berbagai aplikasi berdiri sebagai perantara antara perangkat keras dan perangkat lunak pada sebuah sistem operasi. Filosofi Linux ini kemudian dikenal luas dengan istilah, \sphinxstylestrong{\sphinxhref{https://unix.stackexchange.com/questions/225537/everything-is-a-file}{“Everything is a File”}}: setiap transaksi, proses, dan apapun yang terjadi pada sebuah sistem Unix sejatinya adalah ‘\sphinxstyleemphasis{stream of byte}’ yang berdiri di atas kernel.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-02-03-10-30}.png}
\caption{Komponen\sphinxhyphen{}komponen Linux}\label{\detokenize{sesi1/arsitektur:komponen}}\end{figure}

Jika Kernel digunakan untuk berkomunikasi dengan perangkat keras, maka sebuah \sphinxstylestrong{Shell} pada Linux berfungsi sebagai penghubung antara pengguna dan kernel. Shell dapat menerima berbagai perintah pengguna dan menerjemahkannya menjadi perintah yang dapat dipahami oleh perangkat keras. Berbagai aplikasi juga menggunakan shell untuk melakukan operasi\sphinxhyphen{}operasi yang diinginkan pengguna, misalnya pada antarmuka desktop. Karena setiap operasi adalah ‘file’, maka pengguna yang berbeda dapat melakukan operasi yang berbeda pada sebuah berkas yang sama. Pada Linux, kondisi berikut berlaku:
\begin{itemize}
\item {} 
Tiap program dijalankan oleh \sphinxstyleemphasis{user}/pengguna

\item {} 
Tiap berkas dimiliki oleh pengguna

\item {} 
Tiap pengguna memiliki identitas unik yang membedakan pengguna satu dengan yang lain

\end{itemize}

Dari uraian di atas, dapat disimpulkan bahwa beberapa karakteristik dari Linux adalah sebagai berikut %
\begin{footnote}[1]\sphinxAtStartFootnote
https://www.tutorialspoint.com/operating\_system/os\_linux.htm
%
\end{footnote}:
\begin{itemize}
\item {} 
\sphinxstylestrong{Portabel} \sphinxhyphen{} Portabilitas berarti perangkat lunak dapat bekerja pada berbagai jenis perangkat keras dengan cara yang sama. Kernel Linux dan program aplikasi mendukung instalasi mereka pada semua jenis platform perangkat keras.

\item {} 
\sphinxstylestrong{Open Source} \sphinxhyphen{} Kode sumber Linux tersedia secara gratis dan merupakan proyek pengembangan berbasis komunitas. Beberapa tim bekerja sama untuk meningkatkan kemampuan sistem operasi Linux dan pengembangannya terus berjalan.

\item {} 
\sphinxstylestrong{Multi\sphinxhyphen{}User} \sphinxhyphen{} Linux adalah sistem multiuser yang berarti banyak pengguna dapat mengakses sumber daya sistem seperti memori / ram / program aplikasi pada saat yang bersamaan.

\item {} 
\sphinxstylestrong{Multiprogramming} \sphinxhyphen{} Linux adalah sistem multiprogramming yang berarti banyak aplikasi dapat berjalan pada waktu yang bersamaan.

\item {} 
\sphinxstylestrong{Sistem File Hirarkis} \sphinxhyphen{} Linux menyediakan struktur file standar di mana file sistem / file pengguna disusun dengan struktur yang sama pada berbagai distribusi Linux.

\item {} 
\sphinxstylestrong{Shell} \sphinxhyphen{} Linux menyediakan program penerjemah khusus yang dapat digunakan untuk menjalankan perintah sistem operasi. Dapat digunakan untuk melakukan berbagai jenis operasi, memanggil program aplikasi. dll.

\item {} 
\sphinxstylestrong{Keamanan} \sphinxhyphen{} Linux menyediakan keamanan pengguna menggunakan fitur otentikasi seperti proteksi password dan akses terkontrol ke file/enkripsi data tertentu.

\end{itemize}

 


\subsection{Mengunakan Shell}
\label{\detokenize{sesi1/arsitektur:mengunakan-shell}}
\sphinxstylestrong{Shell Command} merupakan antarmuka untuk melakukan berbagai operasi pada sistem operasi Linux. Meskipun saat ini berbagai Distro Linux telah dilengkapi dengan antarmuka yang sangat canggih, penggunaan Shell untuk operasi sehari\sphinxhyphen{}hari memiliki beberapa kelebihan:
\begin{itemize}
\item {} 
Perintah yang kompleks dapat dilakukan dengan mudah menggunakan Shell (coba: \sphinxcode{\sphinxupquote{cal}})

\item {} 
Shell diperlukan pada saat menggunakan Linux sebagai mesin server: perintah shell jauh lebih cepat dan menggunakan bandwith lebih sedikit apabila koneksi dilakukan dengan shell

\item {} 
Shell dapat diprogram (contoh: \sphinxcode{\sphinxupquote{for i in *.png do ...}})

\item {} 
Penggunaan Shell memungkinkan kustomisasi, misalnya dengan menggunakan argumen untuk berbagai perintah (contoh: \sphinxstyleemphasis{pipe operation})

\end{itemize}

Pada bagian ini akan dilakukan beberapa latihan untuk mengenal perintah\sphinxhyphen{}perintah shell pada Linux. Perintah\sphinxhyphen{}perintah pada panduan ini dilakukan pada Ubuntu, sehingga penggunaan distro yang lain mungkin memerlukan penyesuaian. Meskipun sebagian besar perintah antar distro Linux yang satu dengan yang lain sama, tetapi boleh jadi ada sedikit perbedaan (sebagai contoh, Ubuntu yang berbasis Debian menggunakan Package Manager \sphinxstyleemphasis{apt}, sedangkan CentOS yang berbasis RedHat menggunakan \sphinxstyleemphasis{yum}).

\begin{sphinxadmonition}{note}{Catatan}

\sphinxstylestrong{Bash Shell} adalah aplikasi Command Shell yang saat ini merupakan aplikasi standar pada hampir semua distribusi Linux, sehingga perintah pada panduan ini mengacu pada Bash Shell. Perintah\sphinxhyphen{}perintah pada Bash Shell dapat dilihat pada \sphinxhref{https://devhints.io/bash}{link berikut} atau \sphinxhref{https://courses.cs.washington.edu/courses/cse391/16sp/bash.html}{link berikut}.
\end{sphinxadmonition}

 


\subsubsection{Latihan: Perintah Dasar pada Shell}
\label{\detokenize{sesi1/arsitektur:latihan-perintah-dasar-pada-shell}}
WSL2 untuk Windows 10 yang diinstall pada latihan sebelumnya memberikan antarmuka Shell pada pengguna (lihat {\hyperref[\detokenize{sesi1/pengantarlinux:wsl2}]{\sphinxcrossref{\DUrole{std,std-ref}{gambar sebelumnya}}}}). Latihan\sphinxhyphen{}latihan berikut menggunakan antarmuka \sphinxstyleemphasis{shell command} yang diberikan oleh WSL2 ini.

Berikut adalah beberapa perintah yang dapat digunakan untuk berlatih manajemen file pada Linux:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Command
&\sphinxstyletheadfamily 
Deskripsi
\\
\hline
man
&
bring up manual for a command
\\
\hline
exit
&
log out of shell
\\
\hline
clear
&
clears all output from console
\\
\hline
date
&
output the system date
\\
\hline
cal
&
output a text calendar
\\
\hline
uname
&
print information about the current system
\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Untuk latihan, buka konsol Ubuntu WSL2, kemudian ketikkan salah satu perintah di atas:

\sphinxincludegraphics{{2020-12-02-04-08-05}.png}

Perintah \sphinxcode{\sphinxupquote{pwd}} pada gambar di atas digunakan untuk menampilkan direktori tempat shell saat ini berjalan. Keluaran dari perintah ini langsung ditampilkan pada konsol. Untuk latihan, jalankan perintah\sphinxhyphen{}perintah lain dan perhatikan apa yang terjadi pada konsol.

 


\subsubsection{Latihan: Operasi pada File dan Direktori}
\label{\detokenize{sesi1/arsitektur:latihan-operasi-pada-file-dan-direktori}}
Sebagaimana pada Windows, berkas pada Linux disusun dalam beberapa folder yang masing\sphinxhyphen{}masing mengatur pekerjaan tertentu. Pada Linux, struktur direktorinya adalah sebagai berikut:

\sphinxincludegraphics{{2020-12-02-04-35-50}.png}

Perintah pada Shell umumnya mengikuti struktur sebagai berikut:

\sphinxincludegraphics{{2020-12-02-05-10-13}.png}

\sphinxcode{\sphinxupquote{Command}} adalah perintah yang dipanggil pada shell. \sphinxcode{\sphinxupquote{Flags}} menunjukkan opsi yang dapat dipanggil oleh command tersebut, sedangkan \sphinxcode{\sphinxupquote{Argument}} menyatakan variabel yang dipanggil oleh perintah tersebut.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Untuk berpindah antar satu direktori ke direktori lain, dapat digunakan \sphinxstyleemphasis{Relative Directory}, dimana struktur direktori dapat diakses secara hirarkis.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Command
&\sphinxstyletheadfamily 
Deskripsi
\\
\hline
.
&
direktory saat ini
\\
\hline
..
&
direktory yang berada satu tingkat di atas direktori saat ini
\\
\hline
\textasciitilde{}
&
home directory untuk pengguna saat ini
\\
\hline
/
&
root directory
\\
\hline
/apt
&
folder \sphinxstylestrong{apt} pada root
\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

 

\item {} 
Selanjutnya, perintah\sphinxhyphen{}perintah berikut dapat digunakan pada saat berhubungan dengan pengaturan direktori:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Command
&\sphinxstyletheadfamily 
Deskripsi
\\
\hline
ls
&
tampilkan daftar berkas pada direktori saat ini
\\
\hline
pwd
&
print working directory \sphinxhyphen{} cetak direktori saat ini
\\
\hline
cd
&
change directory \sphinxhyphen{} berpindah ke direktori baru
\\
\hline
mkdir
&
membuat direktori baru
\\
\hline
rmdir
&
menghapus direktori (isi folder harus kosong)
\\
\hline
rm
&
hapus file atau direktori (\sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf}} untuk menghapus secara paksa)
\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

 

\item {} 
Gunakan perintah \sphinxcode{\sphinxupquote{man <namaperintah>}} atau \sphinxcode{\sphinxupquote{namaperintah \sphinxhyphen{}\sphinxhyphen{}help}} untuk menampilkan opsi apa saja yang dapat digunakan pada tiap perintah tersebut. Sebagai contoh berikut adalah manual page untuk perintah \sphinxcode{\sphinxupquote{ls}}:
\sphinxincludegraphics{{2020-12-07-11-00-11}.png}
 

\item {} 
Untuk latihan selanjutnya, tampilkan isi dari \sphinxstylestrong{root directory} (satu tingkat di atas \sphinxcode{\sphinxupquote{home directory}}), seperti berikut:
\sphinxincludegraphics{{2020-12-02-05-08-58}.png}
 

\item {} 
Selanjutnya, buatlah struktur folder berikut pada \sphinxcode{\sphinxupquote{home directory}} Anda (pengguna aktif saat ini):
\sphinxincludegraphics{{2020-12-02-05-01-36}.png}

Buat folder \sphinxcode{\sphinxupquote{workspace}} yang didalamnya berisi dua buah folder, masing\sphinxhyphen{}masing folder \sphinxcode{\sphinxupquote{latihan1}} dan \sphinxcode{\sphinxupquote{latihan2}}. Di dalam folder \sphinxcode{\sphinxupquote{latihan1}} berisi sebuah folder lain.

\begin{sphinxadmonition}{note}{Catatan}

Berbagai perintah pada \sphinxstyleemphasis{shell} Linux sangat efektif apabila digunakan dengan baik. Perintah yang berbeda dapat dikombinasikan dan dioptimalkan untuk mempersingkat tugas\sphinxhyphen{}tugas yang diberikan. Sebagai contoh, beberapa perintah dapat menerima lebih dari satu argumen (misalnya, \sphinxcode{\sphinxupquote{mkdir folder1 folder2}}). Penggunaan operator pada command juga dapat menyingkat operasi yang diinginkan (misalnya, \sphinxcode{\sphinxupquote{sudo apt update \&\& sudo apt update}} dengan operator \sphinxcode{\sphinxupquote{AND\_IF}}), operasi ekspansi dengan bracket (misalnya \sphinxcode{\sphinxupquote{cp /alamat/file.txt\{,.bak\}}})

Sebagai catatan tambahan, Shell pada Linux bahkan mendukung \sphinxhref{https://likegeeks.com/regex-tutorial-linux/}{Regex}!
\end{sphinxadmonition}

 

\item {} 
Untuk bekerja dengan file, beberapa perintah berikut dapat digunakan:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Command
&\sphinxstyletheadfamily 
Deskripsi
\\
\hline
cp
&
copy a file
\\
\hline
mv
&
move a file (also used to rename files)
\\
\hline
rm
&
remove the given file
\\
\hline
touch
&
create empty file, or change time\sphinxhyphen{}modified
\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Gunakan perintah di atas untuk membuat file \sphinxcode{\sphinxupquote{berkas1.txt}} pada \sphinxcode{\sphinxupquote{folder\_a}} di dalam folder \sphinxcode{\sphinxupquote{latihan1}}. Selanjutnya, lakukan perintah copy dan rename untuk menghasilkan struktur file seperti berikut:

\sphinxincludegraphics{{2020-12-02-05-21-44}.png}

untuk melakukan editing pada file, kebanyakan distro Linux menyediakan shell editor bawaan, misalnya \sphinxcode{\sphinxupquote{nano}}.

 

\item {} 
Terakhir, hapus \sphinxstylestrong{folder\_b} berikut semua file dan sub\sphinxhyphen{}direktori di dalamnya. Hasil akhirnya sebagai berikut:

\sphinxincludegraphics{{2020-12-02-05-29-52}.png}

\end{enumerate}

 

Dengan demikian, latihan ini menunjukkan bagaimana manajemen terhadap file dilakukan di Linux. Berbagai perintah dapat digabungkan untuk memperoleh hasil yang diinginkan, misalnya membuat beberapa folder baru sekaligus atau membuat dan mengcopy berkas secara cepat.

 


\subsubsection{Latihan: Instalasi aplikasi}
\label{\detokenize{sesi1/arsitektur:latihan-instalasi-aplikasi}}
Ubuntu menggunakan APT (\sphinxstyleemphasis{Advanced Package Tool}) sebagai \sphinxstyleemphasis{package manager} untuk mengatur seluruh aplikasi yang digunakan. Sebuah Package manager menghubungkan antara Repository dan mesin linux yang kita gunakan. \sphinxhref{https://www.linuxid.net/24289/penjelasan-lengkap-ubuntu-repository-dan-cara-menggunakan-repository/}{\sphinxstylestrong{Repositori Linux}} merupakan lokasi penyimpanan tempat sistem Anda mengambil dan menginstal pembaruan dan aplikasi OS. Setiap repositori adalah kumpulan perangkat lunak yang disimpan pada server jarak jauh dan digunakan untuk menginstal dan memperbarui paket perangkat lunak pada sistem Linux.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-03-02-08-32}.png}
\caption{Cara kerja Package Manager pada Linux}\label{\detokenize{sesi1/arsitektur:apt}}\end{figure}

Pada pemanggilan berkas yang tersimpan di repository, berlaku kondisi sebagaimana akses informasi melalui internet pada umumnya: semakin jauh secara fisik lokasi server, semakin lambat koneksi yang akan diperoleh. Untuk itu, terdapat sejumlah repository lokal untuk tiap versi distribusi Linux. Sebagai contoh, \sphinxurl{http://repo.ugm.ac.id/} berisi repository untuk beberapa distribusi Linux yang disimpan pada server UGM.

Terdapat beberapa antarmuka yang berhubungan dengan Package Manager yang dikenal di sistem operasi berbasis Debian, seperti \sphinxstyleemphasis{apt\sphinxhyphen{}get, aptitude,} maupun \sphinxstyleemphasis{apt}. Aplikasi antarmuka ini menghubungkan perintah dari pengguna (misalnya \sphinxcode{\sphinxupquote{sudo apt update}}) dengan \sphinxstyleemphasis{package manager} (seperti APT) untuk kemudian melakukan operasi terkait dengan basisdata aplikasi pada repository.

Latihan berikut diberikan untuk memahamkan bagaimana menggunakan \sphinxstyleemphasis{apt} untuk memanajemen aplikasi pada Linux %
\begin{footnote}[2]\sphinxAtStartFootnote
https://itsfoss.com/apt\sphinxhyphen{}command\sphinxhyphen{}guide/
%
\end{footnote}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Melakukan \sphinxstyleemphasis{update} basisdata APT
Pada Ubuntu dan distro berbasis Debian lainnya, aplikasi yang terinstall disimpan pada basisdata. Untuk melakukan update atau pembaruan aplikasi dari repository, gunakan perintah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt update
\end{sphinxVerbatim}

keluaran perintah tersebut adalah seperti berikut:

\sphinxincludegraphics{{2020-12-02-05-36-00}.png}

Hasil dari \sphinxcode{\sphinxupquote{apt update}} adalah daftar aplikasi yang dapat diperbarui. Untuk mengeksekusi pembaruan aplikasi, gunakan perintah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt upgrade
\end{sphinxVerbatim}

Kedua perintah di atas dapat diringkas menggunakan \sphinxcode{\sphinxupquote{\&\&}} :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt update \PYG{o}{\PYGZam{}\PYGZam{}} sudo apt upgrade
\end{sphinxVerbatim}

\begin{sphinxadmonition}{caution}{Caution:}
Upgrade adalah hak \sphinxstyleemphasis{sudoers}. Apa yang terjadi jika perintah di atas dijalankan tanpa \sphinxcode{\sphinxupquote{sudo}}?
\end{sphinxadmonition}

\item {} 
\sphinxcode{\sphinxupquote{apt}} dapat digunakan untuk melakukan instalasi paket aplikasi. sebagai contoh, perintah berikut akan menginstall aplikasi \sphinxcode{\sphinxupquote{tree}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt install tree
\end{sphinxVerbatim}

selanjutnya, perintah \sphinxcode{\sphinxupquote{tree}} dapat langsung digunakan pada shell.

\end{enumerate}

 
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Untuk menghapus aplikasi, gunakan perintah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt purge \PYGZlt{}nama aplikasi\PYGZgt{}
\end{sphinxVerbatim}

atau

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt remove \PYGZlt{}nama aplikasi\PYGZgt{}
\end{sphinxVerbatim}

perbedaan keduanya terletak pada kedalaman penghapusan. \sphinxcode{\sphinxupquote{purge}} menghapus seluruh aplikasi berikut konfigurasi yang tersimpan, sedangkan \sphinxcode{\sphinxupquote{remove}} hanya menghapus aplikasi dari daftar basisdata \sphinxstylestrong{APT}, tetapi meninggalkan konfigurasi dari aplikasi, sehingga apabila kelak dilakukan instalasi kembali, konfigurasi ini akan digunakan.

\end{enumerate}

 
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Sebagai latihan, lakukan instalasi untuk aplikasi editing bernama \sphinxcode{\sphinxupquote{vim}}. \sphinxstylestrong{vim} dapat digunakan untuk mengedit sebuah file yang memiliki tingkat kompleksitas tinggi, dan akan membantu pada saat kita melakukan editing file, misalnya pada sebuah mesin server.

\end{enumerate}


\subsection{Pengaturan Pengguna dan Hak Akses}
\label{\detokenize{sesi1/arsitektur:pengaturan-pengguna-dan-hak-akses}}
Sebagaimana disebutkan, Linux merupakan sistem operasi MultiUser dan Multiprogramming, dimana tiap berkas dimiliki oleh seorang pengguna, dan tiap pengguna memiliki hak akses tertentu. \sphinxstyleemphasis{\sphinxstylestrong{Sudoers}} merupakan kelas pengguna yang memiliki hak akses lebih tinggi (\sphinxstyleemphasis{elevated}) dibandingkan pengguna biasa, sehingga mampu melakukan berbagai perintah yang tidak diizinkan untuk pengguna yang tidak termasuk dalam \sphinxstylestrong{grup 27 (sudo)}, misalnya \sphinxcode{\sphinxupquote{apt upgrade}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-02-05-41-38}.png}
\caption{Sumber: https://xkcd.com/149/}\label{\detokenize{sesi1/arsitektur:sudo}}\end{figure}

Beberapa perintah terkait user pada Linux adalah sebagai berikut:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Command
&\sphinxstyletheadfamily 
Deskripsi
\\
\hline
whoami
&
print your username
\\
\hline
id
&
print user id and group membership
\\
\hline
users
&
list logged\sphinxhyphen{}in users (short)
\\
\hline
who
&
list logged\sphinxhyphen{}in users (long)
\\
\hline
finger
&
print information about users
\\
\hline

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Latihan: Administrasi Pengguna}
\label{\detokenize{sesi1/arsitektur:latihan-administrasi-pengguna}}
Latihan berikut akan memberikan gambaran mengenai pengaturan pengguna dan hak akses pada berkas atau direktori %
\begin{footnote}[3]\sphinxAtStartFootnote
https://vitux.com/a\sphinxhyphen{}beginners\sphinxhyphen{}guide\sphinxhyphen{}to\sphinxhyphen{}user\sphinxhyphen{}management\sphinxhyphen{}on\sphinxhyphen{}ubuntu/
%
\end{footnote}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Membuat user baru
Akun pengguna baru dapat digunakan pada sebuah sistem Enterprise, dimana satu sistem operasi yang sama digunakan oleh beberapa pengguna yang berbeda. untuk menambahkan pengguna baru, gunakan perintah berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo adduser namauser
\end{sphinxVerbatim}

Setelah user baru dibuat, kita akan diminta untuk memasukkan nama pengguna dan password, serta beberapa informasi lainnya.

\item {} 
Merubah password
Setelah membuat akun, langkah selanjutnya adalah merubah password untuk akun tersebut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo passwd namauser
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Latihan: Pengaturan Grup}
\label{\detokenize{sesi1/arsitektur:latihan-pengaturan-grup}}
Grup pada Linux dapat digunakan untuk mendefinisikan peranan yang berbeda untuk tiap pengguna, misalnya membatasi akses pada direktori serta akses untuk perintah tertentu. Untuk memasukkan pengguna yang sudah dibuat pada sebuah grup, perintahnya adalah sebagai berikut:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Menambahkan pengguna ke grup

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo usermod –a –G namagrup namauser
\end{sphinxVerbatim}

 

\item {} 
Jika grup yang dimaksud adalah \sphinxstylestrong{sudoer}, maka perintahnya adalah sebagai berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
usermod \PYGZhy{}aG sudo namauser
\end{sphinxVerbatim}

 

\item {} 
Selanjutnya, lakukan penambahan akses pengguna ini ke dalam \sphinxstyleemphasis{sudoer}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo visudo
\end{sphinxVerbatim}

masukkan informasi nama user sebagai \sphinxstyleemphasis{sudoer}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
namauser  \PYG{n+nv}{ALL}\PYG{o}{=}\PYG{o}{(}ALL\PYG{o}{)} NOPASSWD:ALL
\end{sphinxVerbatim}

 

\item {} 
Berpindah akun (switch user)
Untuk keperluan administrasi, seringkali pengguna harus berpindah dari satu akun (non\sphinxhyphen{}sudoer) ke akun lain (sudoer). untuk itu, perintah berikut dapat digunakan:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
su –u userkedua
whoami
\end{sphinxVerbatim}

untuk mengakses \sphinxstyleemphasis{superelevated user} atau \sphinxstylestrong{root}, perintah berikut dapat digunakan:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo su
whoami
\end{sphinxVerbatim}

\end{enumerate}

Grup dapat digunakan untuk mengatur dan mengelompokkan pengguna pada satu hak akses yang sama. Selanjutnya adalah bagaimana melakukan pengaturan hak akses tersebut.


\subsubsection{Pengaturan Hak Akses}
\label{\detokenize{sesi1/arsitektur:pengaturan-hak-akses}}
Sebagaimana disebutkan sebelumnya, akses terhadap file dan perintah pada Linux dapat dibatasi untuk user tertentu. Izin (\sphinxstyleemphasis{Permission}) ini pada linux dibagi menjadi:
\begin{itemize}
\item {} 
\sphinxstylestrong{owner} (u) \sphinxhyphen{} user yang membuat file. ini dapat dirubah menggunakan perintah \sphinxcode{\sphinxupquote{chown}}

\item {} 
\sphinxstylestrong{group} (g) \sphinxhyphen{} grup yang berhubungan dengan tiap file

\item {} 
\sphinxstylestrong{others} (o) \sphinxhyphen{} orang lain yang bukan owner maupun anggota grup yang dapat mengakses file tersebut (‘=semua orang’)

\end{itemize}

Sebagai contoh, jika kita menggunakan perintah \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}al}} berikut:

\sphinxincludegraphics{{2020-12-02-08-39-09}.png}

akan muncul keterangan (\sphinxcode{\sphinxupquote{drwxr\sphinxhyphen{}xr\sphinxhyphen{}x}}) mengenai status dan hak akses pada file tersebut, yaitu:
\begin{itemize}
\item {} 
\sphinxstylestrong{d} : menunjukkan bahwa berkas tersebut adalah sebuah \sphinxcode{\sphinxupquote{directory}}

\item {} 
\sphinxstylestrong{rwx} : permission (izin) yang diberikan pada pemilik file untuk \sphinxstyleemphasis{\sphinxstylestrong{r}ead, \sphinxstylestrong{w}rite dan e}\sphinxstyleemphasis{x}*ecute

\item {} 
\sphinxstylestrong{r\sphinxhyphen{}x} : izin \sphinxstyleemphasis{grup}, pengguna dari grup \sphinxcode{\sphinxupquote{danylaksono}} (kebetulan untuk contoh di atas nama pengguna dan grup sama) dapat melakukan \sphinxstyleemphasis{read dan execute} pada file tersebut

\item {} 
\sphinxstylestrong{r\sphinxhyphen{}x} : izin untuk \sphinxstyleemphasis{other}, atau pengguna lain

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=500\sphinxpxdimen]{{2020-12-03-02-33-45}.png}
\caption{Penjelasan hak akses pada Linux}\label{\detokenize{sesi1/arsitektur:izin}}\end{figure}

Penulisan izin tersebut juga dapat dilakukan menggunakan \sphinxstylestrong{notasi numerik}:
\begin{itemize}
\item {} 
0: Tidak ada izin

\item {} 
1: Jalankan (x)

\item {} 
2: Tulis (w)

\item {} 
4: Baca (r)

\end{itemize}

Sekarang, bagaimana cara menghitung izin untuk pengguna dan grup dalam notasi numerik? Cukup tambahkan nilai izin untuk mendapatkan nilai pengguna, grup, dan izin lainnya masing\sphinxhyphen{}masing.

Sebagai contoh:
\begin{itemize}
\item {} 
Izin \sphinxstyleemphasis{baca} (4), \sphinxstyleemphasis{tulis} (2) dan \sphinxstyleemphasis{jalankan} (1): izin \sphinxstylestrong{rwx} diterjemahkan menjadi 7 (4 + 2 + 1)

\item {} 
Izin \sphinxstyleemphasis{baca} (4) dan \sphinxstyleemphasis{tulis} (2): izin \sphinxstylestrong{rw\sphinxhyphen{}} diterjemahkan menjadi 6 (4 + 2)

\item {} 
Izin \sphinxstyleemphasis{tulis} (2) dan \sphinxstyleemphasis{jalankan} (1): izin \sphinxstylestrong{\sphinxhyphen{}wx} diterjemahkan menjadi 3 (2 + 1), dan seterusnya.

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
Kira\sphinxhyphen{}kira apa pengaruh \sphinxcode{\sphinxupquote{chmod 777}}?
\end{sphinxadmonition}

Dengan menggunakan perintah \sphinxcode{\sphinxupquote{chmod}}, izin suatu file dapat dirubah. perintah ini menggunakan notasi:
\begin{itemize}
\item {} 
tanda minus (\sphinxhyphen{}), yang berarti “hapus izin ini”

\item {} 
tanda tambah (+), yang berarti “tambahkan izin ini”

\item {} 
tanda sama dengan (=), yang berarti “ubah izin menjadi persis seperti ini”.

\end{itemize}

Sebagai contoh:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
chmod +x latihan.txt
\end{sphinxVerbatim}

maksudnya adalah memberi izin kepada semua pengguna untuk mengakses file tersebut. Ini sama dengan \sphinxcode{\sphinxupquote{chmod a+x latihan1.txt}}, dimana \sphinxstylestrong{a} berarti ‘all’. Hal yang sama berlaku untuk \sphinxstyleemphasis{grup} (g) dan \sphinxstyleemphasis{other} (o).

Perintah lain yang berguna untuk merubah kepemilikan berkas pada Linux adalah \sphinxcode{\sphinxupquote{chown}}. Format untuk perintah ini adalah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
chown user\PYG{o}{[}:group\PYG{o}{]} namafile
\end{sphinxVerbatim}

Perintah di atas akan merubah owner untuk file \sphinxcode{\sphinxupquote{namafile}} menjadi \sphinxcode{\sphinxupquote{user}} pada grup \sphinxcode{\sphinxupquote{group}}. Selain file, perintah ini juga dapat digunakan untuk merubah kepemilikan sebuah folder atau direktori. Untuk kasus ini, flag \sphinxcode{\sphinxupquote{\sphinxhyphen{}R}} berguna untuk merubah kepemilikan sebuah direktori secara rekursif, yaitu sekaligus merubah seluruh subdirektory dan berkas yang ada di dalamnya.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
chown \PYGZhy{}R user\PYG{o}{[}:group\PYG{o}{]} direktori
\end{sphinxVerbatim}

Sebagai latihan untuk sesi ini, buat user kedua, kemudian rubah akses pada file \sphinxcode{\sphinxupquote{latihan1.txt}} yang sudah dibuat sebelumnya agar user lain tidak dapat membaca file tersebut. Apa pengaruhnya apabila user pertama hendak mengakses file tersebut?

\begin{sphinxadmonition}{note}{Catatan}

Penggunaan DAC (\sphinxstyleemphasis{Discretionary Access Control}) seperti di atas akan lebih baik apabila dilengkapi dengan pengaturan ACL (\sphinxstyleemphasis{Access Control List}) atau SELinux pada distribusi seperti Centos untuk manajemen berkas pada server.
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\section{Linux sebagai Sistem Operasi Server}
\label{\detokenize{sesi1/linuxserver:linux-sebagai-sistem-operasi-server}}\label{\detokenize{sesi1/linuxserver::doc}}
Linux merupakan salah satu sistem operasi yang paling banyak digunakan untuk server, karena kemampuan enterprise dan biaya yang murah (bahkan gratis). Atas alasan itulah, Linux banyak dijumpai pada berbagai platform mesin server, baik dalam skala besar maupun kecil.  Pada bagian ini akan dilakukan pengaturan Linux untuk sebagai server dengan menggunakan beberapa perangkat \sphinxstyleemphasis{webserver} dan \sphinxstyleemphasis{application server}.


\subsection{Perangkat Lunak untuk Web Server dan Application Server}
\label{\detokenize{sesi1/linuxserver:perangkat-lunak-untuk-web-server-dan-application-server}}
Sebuah aplikasi \sphinxstylestrong{webserver} berguna untuk mempublikasi file lokal agar dapat diakses melalui jaringan. Sebagai contoh, halaman HTML yang dibuat di komputer belum akan dapat diakses secara luas apabila tidak dipasang pada aplikasi webserver yang dapat mempublikasi data ini. Beberapa contoh perangkat Webserver adalah sebagai berikut:
\begin{itemize}
\item {} 
Apache HTTP Server

\item {} 
Nginx

\item {} 
LightHTTPd

\item {} 
Microsoft IIS

\item {} 
NodeJS

\item {} 
Flask

\end{itemize}

Apache adalah salah satu webserver berbasis PHP yang paling sering digunakan. Dengan Apache, maka berkas yang tersimpan pada komputer akan dapat di\sphinxstyleemphasis{online}kan dengan pengaturan tertentu. Pengaturan yang dimaksud meliputi pengaturan keamanan, \sphinxstyleemphasis{virtual host}, \sphinxstyleemphasis{proxy}, dan lain sebagainya.

\sphinxstylestrong{Application Server} merupakan sebuah kelompok \sphinxstyleemphasis{framework} perangkat lunak yang memungkinkan sebuah \sphinxstyleemphasis{web application} untuk disajikan melalui internet. Contoh application server adalah \sphinxstyleemphasis{Java Servlet Container}, yaitu perangkat yang berfungsi untuk menyajikan aplikasi yang dibuat dengan bahasa Java pada internet. Beberapa Contoh Application Server adalah sebagai berikut:
\begin{itemize}
\item {} 
Apache Tomcat

\item {} 
Eclipse Jetty

\item {} 
ASP.Net

\item {} 
ZendServer

\item {} 
JBoss EAP

\end{itemize}

Jika sebuah \sphinxstyleemphasis{webserver} umumnya menyajikan \sphinxstyleemphasis{static content}(seperti HTML, CSS, Javascript, gambar, video, dst) maka sebuah \sphinxstyleemphasis{application server} menyajikan \sphinxstyleemphasis{bussiness logic} yang memungkinkan aplikasi yang disajikan bersifat dinamis.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=500\sphinxpxdimen]{{2020-12-03-03-02-24}.png}
\caption{Perbandingan App Server dan Web Server}\label{\detokenize{sesi1/linuxserver:appserver}}\end{figure}


\subsubsection{Latihan: Menjalankan sebuah Web Server Sederhana}
\label{\detokenize{sesi1/linuxserver:latihan-menjalankan-sebuah-web-server-sederhana}}
Untuk sekedar menguji kemampuan \sphinxstyleemphasis{port forwarding} dari WSL2 dan demonstrasi webserver, kita akan coba untuk membuat sebuah webserver sederhana. Python menyediakan sebuah webserver sederhana dengan perintah singkat:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m http.server  
\end{sphinxVerbatim}

maka folder tempat perintah tersebut dijalankan akan dapat diakses pada browser pada alamat \sphinxcode{\sphinxupquote{localhost:8000}} (port default untuk server ini):

\sphinxincludegraphics{{2020-12-02-12-12-30}.png}

Apabila kita membuat sebuah file HTML pada folder tersebut, maka berkas tersebut dapat dibuka pada browser sebagai sebuah halaman web.


\subsubsection{Instalasi Apache HTTP Server}
\label{\detokenize{sesi1/linuxserver:instalasi-apache-http-server}}
Server web **Apache HTTP Server **adalah perangkat paling populer saat ini untuk menyajikan konten web di internet. Apache menyumbang lebih dari setengah dari seluruh situs web aktif di internet dengan berbagai fungsi dan kelebihan yang dimilikinya.
Pada latihan ini akan dilakukan instalasi dan konfigurasi Apache untuk publikasi data dalam bentuk HTML sederhana.

Lakukan langkah berikut untuk melakukan instalasi Apache pada sistem Ubuntu WSL:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Update basisdata aplikasi di Ubuntu

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 sudo apt update
\end{sphinxVerbatim}

\end{enumerate}

 2. Instalasi Apache2
\sphinxcode{\sphinxupquote{bash     sudo apt install apache2     }}
 3. Pengaturan firewall. Firewall berfungsi untuk ‘mencegat’ terjadinya  transfer data antara sistem lokal dengan jaringan internet. Pengaturan ini diperlukan agar apache diizinkan untuk mengakses port yang diperlukan untuk berkomunikasi dengan dunia luar

\begin{sphinxVerbatim}[commandchars=\\\{\}]
```bash
sudo ufw allow \PYGZsq{}Apache\PYGZsq{}
```

Selanjutnya periksa status `ufw` menggunakan perintah:

```bash
sudo ufw status
```

Apabila keluarannya seperti berikut, artinya port berhasil dibuka:

```
Output
Status: active

To                         Action      From
\PYGZhy{}\PYGZhy{}                         \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}      \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
OpenSSH                    ALLOW       Anywhere                  
Apache                     ALLOW       Anywhere                  
OpenSSH (v6)               ALLOW       Anywhere (v6)             
Apache (v6)                ALLOW       Anywhere (v6)
```
\end{sphinxVerbatim}

 
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Jalankan Apache setelah instalasi

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo service apache2 start
\end{sphinxVerbatim}

Periksa apakah Apache sudah dijalankan oleh \sphinxstyleemphasis{Service}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo service apache2 status
\end{sphinxVerbatim}

Apabila status menunjukkan ‘running’, artinya webserver Apache sudah berhasil dijalankan
\sphinxincludegraphics{{2020-12-02-10-56-11}.png}

\end{enumerate}

 
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Buka localhost melalui browser pada Windows

\sphinxincludegraphics{{2020-12-02-10-57-55}.png}

Apabila halaman Apache Ubuntu sudah terbuka, artinya instalasi Apache berhasil dengan baik

\end{enumerate}

WSL menggunakan \sphinxstyleemphasis{port forwarding} dan perubahan DNS lola pada alamat localhost, sehingga localhost pada WSL akan sama dengan localhost pada Windows. Untuk melihat alamat IP dari port yang digunakan oleh WSL, gunakan perintah \sphinxcode{\sphinxupquote{ip addr}}:

\sphinxincludegraphics{{2020-12-07-11-38-03}.png}

pada bagian \sphinxcode{\sphinxupquote{eth0}}, terdapat ip address yang akan membuka halaman yang sama dengan localhost apabila diakses di Windows. Dalam hal ini alamat tersebut adalah \sphinxcode{\sphinxupquote{172.17.27.221}}.


\subsubsection{Membuat Website sederhana}
\label{\detokenize{sesi1/linuxserver:membuat-website-sederhana}}
Setelah webserver selesai dipasang, selanjutnya adalah menggunakan webserver ini untuk mempublikasi halaman web dalam bentuk HTML. Apache memiliki direktori default dalam publikasi webnya di folder:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{www}\PYG{o}{/}\PYG{n}{html}
\end{sphinxVerbatim}

Dengan demikian, seluruh file yang disimpan pada folder tersebut akan dapat dibuka melalui browser pada alamat \sphinxcode{\sphinxupquote{localhost}}.
Untuk menguji webserver ini, kita akan lakukan latihan sebagai berikut:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Masuk ke folder \sphinxcode{\sphinxupquote{/var/www/html}} menggunakan perintah \sphinxcode{\sphinxupquote{cd}}.
 

\item {} 
Buat sebuah folder baru dengan nama \sphinxcode{\sphinxupquote{trial}} pada direktori \sphinxcode{\sphinxupquote{/html}} tersebut.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo mkdir trial
\end{sphinxVerbatim}

Perintah \sphinxcode{\sphinxupquote{mkdir}} pada folder tersebut memerlukan akses \sphinxcode{\sphinxupquote{sudo}}, karena owner dari folder adalah \sphinxcode{\sphinxupquote{root}}.
 

\item {} 
Pada folder tersebut, buat sebuah file dengan nama \sphinxcode{\sphinxupquote{index.html}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo touch index.html
\end{sphinxVerbatim}

 

\item {} 
Isilah file tersebut dengan baris bahasa HTML berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{html}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{head}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{head}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{body}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{h1}\PYG{p}{\PYGZgt{}} The hello world\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{h1}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}} Ini paragraf html \PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{p}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{body}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{html}\PYG{p}{\PYGZgt{}}   
\end{sphinxVerbatim}

 

\item {} 
Buka http://localhost/trial:
\sphinxincludegraphics{{2020-12-02-12-38-31}.png}
File html yang dibuat pada folder berhasil dipanggil pada webserver

\end{enumerate}


\subsection{Tomcat sebagai Servlet Aplikasi berbasis Java}
\label{\detokenize{sesi1/linuxserver:tomcat-sebagai-servlet-aplikasi-berbasis-java}}
Apache Tomcat adalah implementasi open\sphinxhyphen{}source dari Java Servlet, JavaServer Pages, Java Expression Language, dan teknologi Java WebSocket. Tomcat merupakan salah satu web Application yang paling banyak diadopsi di dunia saat ini. Tomcat mudah digunakan dan memiliki ekosistem add\sphinxhyphen{}on yang kuat. Apache Tomcat digunakan untuk publikasi berbagai aplikasi geospasial berbasis Java, seperti misalnya Geoserver, GeoTools dan Mapstore.


\subsubsection{Instalasi Tomcat}
\label{\detokenize{sesi1/linuxserver:instalasi-tomcat}}
Untuk melakukan instalasi Tomcat, lakukan langkah berikut:
//https://linuxize.com/post/how\sphinxhyphen{}to\sphinxhyphen{}install\sphinxhyphen{}tomcat\sphinxhyphen{}9\sphinxhyphen{}on\sphinxhyphen{}ubuntu\sphinxhyphen{}18\sphinxhyphen{}04/
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Update apk, kemudian install OpenJDK. OpenJDK diperlukan oleh Tomcat yang berbasis Java untuk dapat dijalankan pada Ubuntu

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt install default\PYGZhy{}jdk
\end{sphinxVerbatim}

 

\item {} 
Atas alasan keamanan, Tomcat tidak boleh dijalankan di bawah pengguna root. Kita perlu membuat pengguna dan grup sistem baru dengan direktori home /opt/tomcat yang akan menjalankan layanan Tomcat:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo useradd \PYGZhy{}r \PYGZhy{}m \PYGZhy{}U \PYGZhy{}d /opt/tomcat \PYGZhy{}s /bin/false tomcat
\end{sphinxVerbatim}

 

\item {} 
Unduh instalasi Tomcat 9. Pada saat penulisan modul ini, Versi terbaru Tomcat adalah 9.0.40. Sesuaikan versi Tomcat yang digunakan dengan melihat versi rilis terbaru pada \sphinxhref{https://tomcat.apache.org/download-90.cgi}{halaman ini}.
Gunakan wget untuk mengunduh binary Tomcat untuk Instalasi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
wget http://www\PYGZhy{}eu.apache.org/dist/tomcat/tomcat\PYGZhy{}9/v9.0.40/bin/apache\PYGZhy{}tomcat\PYGZhy{}9.0.40.tar.gz \PYGZhy{}P /tmp
\end{sphinxVerbatim}

 

\item {} 
Setelah unduhan selesai, gunakan perintah berikut untuk mengekstrak dan memindah file Tomcat pada folder \sphinxcode{\sphinxupquote{/opt/tomcat}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo tar xf /tmp/apache\PYGZhy{}tomcat\PYGZhy{}9*.tar.gz \PYGZhy{}C /opt/tomcat
\end{sphinxVerbatim}

 

\item {} 
Untuk keperluan praktis, lebih baik apabila dibuat sebuah Symbolic Link untuk mengacu pada binary yang dimaksud:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo ln \PYGZhy{}s /opt/tomcat/apache\PYGZhy{}tomcat\PYGZhy{}9.0.40 /opt/tomcat/latest
\end{sphinxVerbatim}

 

\item {} 
Agar folder tomcat dimiliki oleh pengguna \sphinxcode{\sphinxupquote{tomcat}} yang telah dibuat sebelumnya, gunakan perintah berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo chown \PYGZhy{}RH tomcat: /opt/tomcat/latest
\end{sphinxVerbatim}

Demikian pula, rubah pengaturan akses pada script yang ada di dalamnya agar dapat dieksekusi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo sh \PYGZhy{}c \PYG{l+s+s1}{\PYGZsq{}chmod +x /opt/tomcat/latest/bin/*.sh\PYGZsq{}}
\end{sphinxVerbatim}

 

\item {} 
Untuk memudahkan manajemen, Tomcat perlu dijalankan sebagai service:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo nano /etc/systemd/system/tomcat.service
\end{sphinxVerbatim}

masukkan baris berikut pada file yang dibuka:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Unit}\PYG{p}{]}
\PYG{n}{Description}\PYG{o}{=}\PYG{n}{Tomcat} \PYG{l+m+mi}{9} \PYG{n}{servlet} \PYG{n}{container}
\PYG{n}{After}\PYG{o}{=}\PYG{n}{network}\PYG{o}{.}\PYG{n}{target}

\PYG{p}{[}\PYG{n}{Service}\PYG{p}{]}
\PYG{n}{Type}\PYG{o}{=}\PYG{n}{forking}

\PYG{n}{User}\PYG{o}{=}\PYG{n}{tomcat}
\PYG{n}{Group}\PYG{o}{=}\PYG{n}{tomcat}

\PYG{n}{Environment}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{JAVA\PYGZus{}HOME=/usr/lib/jvm/default\PYGZhy{}java}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{Environment}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{JAVA\PYGZus{}OPTS=\PYGZhy{}Djava.security.egd=file:///dev/urandom \PYGZhy{}Djava.awt.headless=true}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{Environment}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CATALINA\PYGZus{}BASE=/opt/tomcat/latest}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{Environment}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CATALINA\PYGZus{}HOME=/opt/tomcat/latest}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{Environment}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CATALINA\PYGZus{}PID=/opt/tomcat/latest/temp/tomcat.pid}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{Environment}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CATALINA\PYGZus{}OPTS=\PYGZhy{}Xms512M \PYGZhy{}Xmx1024M \PYGZhy{}server \PYGZhy{}XX:+UseParallelGC}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{ExecStart}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{tomcat}\PYG{o}{/}\PYG{n}{latest}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{startup}\PYG{o}{.}\PYG{n}{sh}
\PYG{n}{ExecStop}\PYG{o}{=}\PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{tomcat}\PYG{o}{/}\PYG{n}{latest}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{shutdown}\PYG{o}{.}\PYG{n}{sh}

\PYG{p}{[}\PYG{n}{Install}\PYG{p}{]}
\PYG{n}{WantedBy}\PYG{o}{=}\PYG{n}{multi}\PYG{o}{\PYGZhy{}}\PYG{n}{user}\PYG{o}{.}\PYG{n}{target}
\end{sphinxVerbatim}

 

\item {} 
Lakukan aktivasi untuk Tomcat yang sudah diinstall:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo systemctl daemon\PYGZhy{}reload
sudo systemctl start tomcat
sudo systemctl status tomcat
\end{sphinxVerbatim}

Aktifkan tomcat pada saat mesin dimulai:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo systemctl \PYG{n+nb}{enable} tomcat
\end{sphinxVerbatim}

 

\item {} 
Izinkan Firewall untuk Tomcat.
Sama seperti pada Apache, firewall perlu dibuka untuk mengizinkan Tomcat dapat diakses:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo ufw allow \PYG{l+m}{8080}/tcp
\end{sphinxVerbatim}

 

\item {} 
Buka localhost:8080 pada browser di Windows untuk memeriksa apakah Tomcat sudah berhasil dijalankan

\sphinxincludegraphics{{2020-12-03-05-06-39}.png}

\end{enumerate}

\begin{sphinxadmonition}{note}{Catatan}

Saat panduan ini ditulis, \sphinxhref{https://github.com/systemd/systemd/issues/8036}{WSL2 belum memiliki support untuk \sphinxcode{\sphinxupquote{systemd}}}, sehingga perintah \sphinxcode{\sphinxupquote{sudo systemctl daemon\sphinxhyphen{}reload}} dan seterusnya di atas akan menghasilkan error.

Untuk saat ini, berikut adalah cara yang dapat digunakan sebagai \sphinxstyleemphasis{workaround}. Metode ini diambil dari \sphinxhref{https://github.com/DamionGans/ubuntu-wsl2-systemd-script}{repository github berikut}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Install Git. Git akan digunakan untuk melakukan clone pada repository yang dimaksud:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt install git
\end{sphinxVerbatim}

\item {} 
Lakukan clone pada repository di atas. Sebelum menjalankan perintah ini, pastikan pengguna aktif memiliki izin akses pada folder di dalamnya:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/DamionGans/ubuntu\PYGZhy{}wsl2\PYGZhy{}systemd\PYGZhy{}script.git
\end{sphinxVerbatim}

\item {} 
Masuk ke dalam folder hasil clone, kemudian lakukan eksekusi pada script di dalamnya:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} ubuntu\PYGZhy{}wsl2\PYGZhy{}systemd\PYGZhy{}script/
bash ubuntu\PYGZhy{}wsl2\PYGZhy{}systemd\PYGZhy{}script.sh
\end{sphinxVerbatim}

\item {} 
Tunggu sampai script selesai di eksekusi, kemudian lakukan restart pada konsol WSL (tutup jendela konsol, kemudian buka kembali)

\item {} 
Untuk menguji apakah workaround sudah berjalan, ketikkan perintah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
systemctl
\end{sphinxVerbatim}

\end{enumerate}

apabila tidak muncul error, maka perbaikan sistem berhasil dilakukan, dan \sphinxcode{\sphinxupquote{systemctl}} sudah bisa digunakan
\end{sphinxadmonition}


\section{Free and Open Source Software\sphinxhyphen{}GIS}
\label{\detokenize{sesi1/fossgis:free-and-open-source-software-gis}}\label{\detokenize{sesi1/fossgis::doc}}
Saat Anda sedang membaca panduan ini, barangkali dapat kita asumsikan bahwa Anda saat ini menggunakan sistem operasi Windows 10, dengan beberapa perangkat lunak GIS berbayar maupun open source di dalamnya. Pada bagian ini akan dibahas mengenai perangkat lunak ‘bebas dan terbuka’ (Free and Open Source) yang difungsikan khususnya untuk aplikasi di bidang Informasi Geospasial.


\subsection{Mengenal Lisensi Perangkat Lunak OpenSource}
\label{\detokenize{sesi1/fossgis:mengenal-lisensi-perangkat-lunak-opensource}}
Seringkali terdapat kesalah\sphinxhyphen{}pahaman mengenai aplikasi Open Source. Banyak yang menganggap bahwa apabila suatu perangkat lunak diberi label ‘opensource’ maka dengan sendirinya aplikasi tersebut akan gratis alias tidak berbayar. Pada bagian ini akan dijelaskan secara singkat mengenai pengertian free dan opensource, serta bagaimana pembangun aplikasi (developer) menerapkan dan memilih lisensi perangkat lunak ini.


\subsubsection{Free as in \sphinxstyleliteralintitle{\sphinxupquote{Free\sphinxhyphen{}Speech}} dan \sphinxstyleliteralintitle{\sphinxupquote{Free\sphinxhyphen{}Drinks}}}
\label{\detokenize{sesi1/fossgis:free-as-in-free-speech-dan-free-drinks}}
Perangkat lunak gratis atau ‘free’ mengindikasikan bahwa kita tidak perlu membayar biaya apapun pada saat menggunakan perangkat lunak ini. Meskipun demikian, tidak semua perangkat lunak gratis adalah open source. Demikian juga sebaliknya, tidak semua aplikasi yang bersifat open source maka dengan sendirinya akan menjadi gratis.

Pada bagian mengenai sejarah Linux seperti yang kita jumpai di bagian awal buku ini, terdapat pembahasan mengenai bagaimana Kernel Linux yang dikembangkan oleh Linus Torvalds kemudian dapat digunakan secara bebas oleh siapapun, dimana setiap orang bebas membuat copy, memodifikasi, merilis Linux dengan versinya sendiri, bahkan memungut biaya untuk kode yang telah dimodifikasinya (seperti pada ElementaryOS). Hal ini dimungkinkan karena Linus memberikan lisensi \sphinxhref{https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html}{GNU/GPL versi 2.0 (GPL\sphinxhyphen{}2.0)}, sebagaimana diterbitkan oleh Free Software Foundation yang mengatur hal\sphinxhyphen{}hal tersebut di atas. Bagaimana jika Linus, misalnya, meminta satu dollar untuk tiap penggunaan kernel tersebut? atau ia melarang orang lain untuk mendistribusikan ulang kernel Linux yang dimilikinya, atau melakukan hal\sphinxhyphen{}hal lain seperti yang dapat dilakukan pada kode tersebut di atas secara cuma\sphinxhyphen{}cuma?

Perlu dipahami bahwa ‘Free’ tidak selalu berarti aplikasi tersebut bebas untuk digunakan apa saja. Terdapat perbedaan antara pengertian \sphinxcode{\sphinxupquote{free as in free beer}} dan \sphinxcode{\sphinxupquote{free as in free speech}}: \sphinxstylestrong{gratis} berbeda dengan \sphinxstylestrong{bebas}. “\sphinxstyleemphasis{Free as in free beer}” mengacu pada biaya (yaitu uang) yang harus dikeluarkan untuk menggunakan perangkat lunak tersebut, sedangkan “\sphinxstyleemphasis{free as in free speech}” mengacu pada apa yang boleh Anda lakukan dengan perangkat lunak tersebut. Dalam pengembangan perangkat lunak, dimana biaya produksi massal relatif kecil, biasanya pengembang memang menyediakan perangkat lunak tanpa biaya. Richard Stallman, perintis GNU, merupakan pelopor lisensi bebas terbuka ini, yang kemudian membuka pintu untuk pengembangan Linux oleh Linus Torvalds.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=500\sphinxpxdimen]{{2020-12-07-13-34-29}.png}
\caption{“Think Free Speech, not Free Beer”}\label{\detokenize{sesi1/fossgis:freebeear}}\end{figure}
\begin{quote}

“\sphinxstyleemphasis{’Free software’ is a matter of liberty, not price. To understand the concept, you should think of “free” as in “free speech”, not as in “free beer”}.”

(\sphinxstylestrong{Free Software Definition, Richard Stallman})
\end{quote}

Terdapat 10 faktor berbeda yang mendefinisikan mengenai penggunaan perangkat lunak open source sebagaimana dijelaskan dalam \sphinxhref{https://opensource.org/docs/osd}{OSD (Open Source Definition)}:

\begin{sphinxadmonition}{note}{Catatan}

Bagian ini tidak diterjemahkan agar tidak merubah makna
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstylestrong{Free Redistribution}  The license shall not restrict any party from selling or giving away the software as a component of an aggregate software distribution containing programs from several different sources. The license shall not require a royalty or other fee for such sale.

\item {} 
\sphinxstylestrong{Source Code}  The program must include source code, and must allow distribution in source code as well as compiled form. Where some form of a product is not distributed with source code, there must be a well\sphinxhyphen{}publicized means of obtaining the source code for no more than a reasonable reproduction cost, preferably downloading via the Internet without charge. The source code must be the preferred form in which a programmer would modify the program. Deliberately obfuscated source code is not allowed. Intermediate forms such as the output of a preprocessor or translator are not allowed.

\item {} 
\sphinxstylestrong{Derived Works}  The license must allow modifications and derived works, and must allow them to be distributed under the same terms as the license of the original software.

\item {} 
\sphinxstylestrong{Integrity of The Author’s Source Code}  The license may restrict source\sphinxhyphen{}code from being distributed in modified form only if the license allows the distribution of “patch files” with the source code for the purpose of modifying the program at build time. The license must explicitly permit distribution of software built from modified source code. The license may require derived works to carry a different name or version number from the original software.

\item {} 
\sphinxstylestrong{No Discrimination Against Persons or Groups}  The license must not discriminate against any person or group of persons.

\item {} 
\sphinxstylestrong{No Discrimination Against Fields of Endeavor}  The license must not restrict anyone from making use of the program in a specific field of endeavor. For example, it may not restrict the program from being used in a business, or from being used for genetic research.

\item {} 
\sphinxstylestrong{Distribution of License}  The rights attached to the program must apply to all to whom the program is redistributed without the need for execution of an additional license by those parties.

\item {} 
\sphinxstylestrong{License Must Not Be Specific to a Product}  The rights attached to the program must not depend on the program’s being part of a particular software distribution. If the program is extracted from that distribution and used or distributed within the terms of the program’s license, all parties to whom the program is redistributed should have the same rights as those that are granted in conjunction with the original software distribution.

\item {} 
\sphinxstylestrong{License Must Not Restrict Other Software}  The license must not place restrictions on other software that is distributed along with the licensed software. For example, the license must not insist that all other programs distributed on the same medium must be open\sphinxhyphen{}source software.

\item {} 
\sphinxstylestrong{License Must Be Technology\sphinxhyphen{}Neutral}  No provision of the license may be predicated on any individual technology or style of interface.

\end{enumerate}

Perbedaan penggunaan definisi dari lisensi tersebut memberikan ruang bagi pengembang untuk memilih lisensi yang sesuai dengan kebutuhannya, sebagaimana penjelasan di bawah ini:


\subsubsection{Lisensi Perangkat Lunak}
\label{\detokenize{sesi1/fossgis:lisensi-perangkat-lunak}}
Sebagaimana disebutkan di atas, pengembang aplikasi menggunakan lisensi untuk mendefinisikan batasan apa yang boleh dan tidak boleh dilakukan terhadap perangkat lunak yang mereka buat. \sphinxstyleemphasis{Lisensi open source} adalah lisensi yang sesuai dengan Open Source Definition \sphinxhyphen{} singkatnya, lisensi tersebut memungkinkan perangkat lunak untuk digunakan, dimodifikasi, dan dibagikan secara bebas. Untuk disetujui oleh Open Source Initiative (juga dikenal sebagai OSI), lisensi harus melalui proses peninjauan lisensi oleh \sphinxhref{https://opensource.org/licenses}{Open Source Initiative}.

Para pembuat aplikasi (\sphinxstyleemphasis{developer}) memberikan lisensi sebagai bagian yang tidak dapat dipisahkan dari kode sumber (\sphinxstyleemphasis{source code}) aplikasi yang mereka buat. Pada beberapa lisensi, aturan terhadap \sphinxstyleemphasis{derived works}, misalnya, dibatasi sehingga produk turunan tidak boleh menggunakan lisensi yang lebih ketat dibanding lisensi yang diberikan. Sebagai contoh, dokumen ini menggunakan lisensi \sphinxhref{https://creativecommons.org/licenses/by-sa/4.0/}{CC\sphinxhyphen{}BY\sphinxhyphen{}SA\sphinxhyphen{}4.0} sebagaimana disebutkan pada halaman depan. Ini berarti, sebagian atau keseluruhan modul ini, berikut turunannya, \sphinxstylestrong{dilarang untuk digunakan secara komersial}.

Berikut adalah rangkuman lisensi perangkat lunak dan batasan masing\sphinxhyphen{}masing:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-02-05-54-51}.png}
\caption{Perbandingan Lisensi Perangkat Lunak FOSS}\label{\detokenize{sesi1/fossgis:licenses}}\end{figure}

\begin{sphinxadmonition}{note}{Catatan}

Terdapat perbedaan antara lisensi perangkat lunak dan lisensi dokumen. Lisensi perangkat lunak seperti disebutkan di atas membatasi penggunaan khusus perangkat lunak, kode sumber dan (mungkin) dokumentasi yang menyertainya. Lisensi buku terbuka seperti disebutkan untuk dokumen ini berlaku pada naskah tertulis.
\end{sphinxadmonition}

Beberapa lisensi Open Source yang populer adalah sebagai berikut:
\begin{itemize}
\item {} 
Apache License 2.0

\item {} 
BSD 3\sphinxhyphen{}Clause “New” or “Revised” license

\item {} 
BSD 2\sphinxhyphen{}Clause “Simplified” or “FreeBSD” license

\item {} 
GNU General Public License (GPL)

\item {} 
GNU Library or “Lesser” General Public License (LGPL)

\item {} 
MIT license

\item {} 
Mozilla Public License 2.0

\item {} 
Common Development and Distribution License

\item {} 
Eclipse Public License version 2.0

\end{itemize}

Website berikut memberikan perbandingan dan panduan yang dapat digunakan untuk memilih perangkat lunak mana yang ingin Anda gunakan untuk perangkat lunak Anda tersebut. Website ini juga dapat menjadi panduan pada saat menggunakan perangkat lunak \sphinxstyleemphasis{open source}.
\begin{quote}

https://choosealicense.com/licenses/
\end{quote}

\begin{sphinxadmonition}{note}{Catatan}

Pembahasan ini seharusnya telah memberikan gambaran kepada Anda mengenai jawaban pertanyaan, seperti, “\sphinxstyleemphasis{Seandainya saya membuat QGIS yang saya distribusikan dengan nama saya sendiri, apakah saya diizinkan}?”
\end{sphinxadmonition}


\subsection{Sekilas Tentang Perangkat FOSS\sphinxhyphen{}GIS}
\label{\detokenize{sesi1/fossgis:sekilas-tentang-perangkat-foss-gis}}
Perangkat lunak FOSS (Free and Open Source) dapat dijumpai dalam berbagai bentuk, mulai kernel (seperti Linux), Sistem Operasi, perangkat lunak pengolah kata (\sphinxstyleemphasis{word processor}), analisis data, hingga \sphinxstyleemphasis{machine learning} dan analisis \sphinxstyleemphasis{big data}. Demikian pula, pada bidang Sistem Informasi Geografis, terdapat banyak aplikasi free and open source yang dapat digunakan untuk menggantikan dan/atau melengkapi perangkat lunak \sphinxstyleemphasis{proprietary} yang digunakan saat ini.

Berbagai perangkat Lunak ini (kita sebut saja sebagai perangkat \sphinxstylestrong{FOSS\sphinxhyphen{}GIS}, \sphinxstyleemphasis{Free and Open Source GIS}) tersedia untuk berbagai keperluan di bidang SIG, mulai dari akuisisi data, analisis, penyimpanan data spasial hingga visualisasi pada media desktop dan web. Dapat dikatakan bahwa ekosistem aplikasi FOSS\sphinxhyphen{}GIS telah sedemikian matang sehingga hampir tiap aplikasi berbayar untuk keperluan GIS dapat diperoleh satu atau beberapa aplikasi open source yang dapat menggantikannya.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-07-14-20-24}.png}
\caption{Beberapa perangkat lunak FOSS\sphinxhyphen{}GIS}\label{\detokenize{sesi1/fossgis:fossgisapp}}\end{figure}

FOSS\sphinxhyphen{}GIS tidak hanya tentang perangkat lunak. Sebagaimana disebutkan, ekosistem Open Source pada proses bisnis geospasial meliputi berbagai bidang, \sphinxhref{https://www.osgeo.org/about/what-is-open-source/}{diantaranya}:
\begin{itemize}
\item {} 
\sphinxstylestrong{Open Data} menerapkan prinsip bebas dan terbuka untuk data geospasial. Prinsip bebas dan terbuka ini lebih dari sekadar menerbitkan informasi dengan akses gratis. Data terbuka menyediakan mekanisme bagi peserta untuk memberikan kontribusi sebagai mitra yang setara dalam pengumpulan dan peninjauan terhadap data.

\item {} 
\sphinxstylestrong{Open Education} menerapkan prinsip\sphinxhyphen{}prinsip open source untuk pembuatan bahan ajar yang memungkinkan organisasi untuk berbagi bahan silabus mengurangi biaya dan menjangkau khalayak yang lebih luas.

\item {} 
\sphinxstylestrong{Open Science} menggabungkan ide\sphinxhyphen{}ide ini untuk mewujudkan tujuan penelitian dengan lebih baik, dengan berbagi data yang digunakan untuk mendukung kesimpulan, di samping perangkat lunak sopensource yang digunakan untuk analisis.

\item {} 
\sphinxstylestrong{Open Standard} mempromosikan interoperabilitas antara aplikasi, organisasi, dan bidang usaha. Standar terbuka adalah alat utama yang memungkinkan praktisi geospasial untuk bekerja sama, dengan manfaat tambahan untuk menghindari penguncian teknologi (\sphinxstyleemphasis{vendor\sphinxhyphen{}locked}).

\end{itemize}

Beberapa perangkat lunak FOSS\sphinxhyphen{}GIS yang populer antara lain:
\begin{itemize}
\item {} 
QGIS

\item {} 
Grass GIS

\item {} 
Orfeo Toolbox

\item {} 
GDAL/OGR

\item {} 
Geoserver

\item {} 
PostGIS

\item {} 
Berbagai Library dalam berbagai bahasa (Python, Java, Javascript, etc.), seperti Geopandas, Numpy, Proj4, LeafletJS, dst (\sphinxstyleemphasis{the list is too long!})

\end{itemize}

\sphinxhref{https://github.com/sacridini/Awesome-Geospatial}{Link ini} berisi daftar panjang berbagai aplikasi, data dan tutorial tentang perangkat lunak GIS, baik yang berbayar maupun khususnya yang bersifat FOSS. Anda perlu meluangkan waktu yang tidak sebentar untuk menjelajah seluruh daftar yang tersedia.


\subsubsection{Komunitas FOSS\sphinxhyphen{}GIS}
\label{\detokenize{sesi1/fossgis:komunitas-foss-gis}}
Seperti yang dapat kita lihat pada Linux dan proyek Open Source lainnya, pengguna dan komunitas adalah kekuatan utama berkembangnya perangkat lunak FOSS. Dengan lisensi yang bebas dan terbuka, pengembangan aplikasi menjadi optimal karena banyak yang berkontribusi dalam membagikan \sphinxstyleemphasis{bug}, menyumbang ide pengembangan, maupun menyumbang dana untuk pengembangan aplikasi (Konsepsi yang dikenal sebagai Hukum Linus, “\sphinxstyleemphasis{Given enough eyebalss, all bugs are shallow}”). Diantara yang dapat diamati pada perangkat lunak berbasis Open Source adalah pengembangannya yang luar biasa cepat. Versi terbaru dari Ubuntu \sphinxhref{https://wiki.ubuntu.com/Releases}{dirilis tiap 6 (tiga) bulan sekali}, dengan versi LTS tiap dua tahun sekali. Pada tiap rilis, dapat dijumpai versi baru, bug fix, berbagai fitur dan modul yang merupakan masukan dari pengguna serta hasil pengembangan secara terus menerus. Platform seperti Github dan GitLab memungkinkan pengguna dan pengembang untuk bertukar ide sambil mengembangkan aplikasi sebagai bagian dari komunitas.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=550\sphinxpxdimen]{{2020-12-07-17-26-53}.png}
\caption{Halaman Issues pada Github QGIS. Dapat dilihat beberapa \sphinxstyleemphasis{Feature Request} dan \sphinxstyleemphasis{Bug} yang diajukan oleh komunitas}\label{\detokenize{sesi1/fossgis:qgisissue}}\end{figure}

Sebagai sebuah komunitas matang dengan sejarah yang dapat dilacak \sphinxhref{https://thenewstack.io/humble-beginnings-world-changing-applications-history-open-source-gis/}{hingga awal tahun 80an} melalui MOSS (\sphinxstyleemphasis{Map Overlay and Statistical System}) dan Grass GIS (\sphinxstyleemphasis{Geographic Resources Analysis Support System}). Komunitas FOSS\sphinxhyphen{}GIS berkembang dengan adanya kebutuhan akan aplikasi GIS yang mampu menangani berbagai fungsi yang semakin kompleks seiring perkembangan teknologi komputasi. \sphinxstyleemphasis{Open Grass Fundation} (OGF) dimulai sejak tahun 1992, dan menjadi cikal bakal dari OGC (\sphinxstyleemphasis{Open Geospatial Consortium}) yang merupakan lembaga standarisasi internasional untuk data dan informasi geospasial.

\sphinxhref{https://www.osgeo.org}{OSGeo} merupakan lembaga yang menjadi pendorong utama komunitas FOSS\sphinxhyphen{}GIS saat ini. Open Source Geospatial Foundation (OSGeo) adalah organisasi nirlaba yang misinya adalah untuk mendorong adopsi global teknologi geospasial terbuka dengan menjadi yayasan perangkat lunak inklusif yang dikhususkan untuk filosofi terbuka dan pembangunan berbasis masyarakat partisipatif. Di bawah payung \sphinxstyleemphasis{\sphinxhref{https://www.osgeo.org/choose-a-project/}{OSGeo Projects}}, berbagai aplikasi open source GIS memiliki wadah untuk tumbuh dan berkembang hingga menjadi penggerak utama di berbagai aspek di bidang geospasial.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=350\sphinxpxdimen]{{2020-12-07-18-08-59}.png}
\caption{Beberapa aplikasi yang berada di bawah payung \sphinxhref{https://www.osgeo.org/projects/}{OSGeo Projects}}\label{\detokenize{sesi1/fossgis:osgeoprojects}}\end{figure}


\subsubsection{Latihan: Menggunakan OSGeo Live}
\label{\detokenize{sesi1/fossgis:latihan-menggunakan-osgeo-live}}
Dengan banyaknya aplikasi Open Source yang tersedia (bahkan hanya yang di bawah payung OSGeo saja sudah sangat banyak!), tentu untuk mencoba instalasi satu\sphinxhyphen{}persatu aplikasi tersebut akan memakan waktu. OSGeo telah menyediakan distro khusus yang telah diisi dengan semua aplikasi OSGeo. \sphinxhref{https://live.osgeo.org/en/index.html}{OSGeo Live} merupakan distro khusus berbasis \sphinxstyleemphasis{Lubuntu} yang telah dilengkapi dengan beragam aplikasi pada OSGeo Project:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=350\sphinxpxdimen]{{2020-12-07-18-28-16}.png}
\caption{Beberapa aplikasi pada OSGeo Live}\label{\detokenize{sesi1/fossgis:osgeoproject}}\end{figure}

Sebagaimana distro Linux lainnya, OSGeoLive dapat digunakan sebagai sebuah \sphinxhref{https://www.computerworld.com/article/2519158/5-ways-to-use-bootable-linux-live-discs.html}{Linux Live} yang dipasang pada DVD maupun USB pada saat Boot. Berbeda dengan instalasi sistem operasi pada umumnya, Linux Live tidak akan meninggalkan jejak pada harddisk di komputer tempat ia dijalankan. Seluruh proses sistem operasinya akan diajalankan dari DVD dan USB, dan begitu selesai, sistem berikut data yang dibuat juga akan hilang. Pada latihan ini akan dibuat sebuah mesin Linux Live menggunakan distro OSGeo Live.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Langkah pertama adalah mengunduh perangkat lunak yang dapat digunakan untuk membuat Linux Live USB. Diantara perangkat yang dapat digunakan adalah \sphinxhref{https://www.linuxliveusb.com/}{LinuxLiveUSB} dan \sphinxhref{https://rufus.ie/}{Rufus}. Pada latihan ini akan diunduh \sphinxstylestrong{Rufus} untuk membuat Live OSGeo pada USB. Unduh Rufus dari alamat web rufus di atas atau \sphinxhref{https://github.com/pbatard/rufus/releases/}{rilis terbaru pada Github}.

\item {} 
Unduh ISO dari OSGeo Live (\sphinxstylestrong{osgeolive iso}) pada alamat https://live.osgeo.org/en/download.html. Perlu diingat bahwa ukuran unduhan adalah sekitar 4 GB, jadi pastikan bahwa Anda memiliki koneksi internet yang memadai

\item {} 
Buka Rufus, kemudian masukkan \sphinxstylestrong{USB Flashdisk} kosong yang akan digunakan sebagai Bootable USB. Rufus akan mendeteksi secara otomatis USB Flashdisk yang akan digunakan.

\item {} 
Selanjutnya, pada bagian \sphinxcode{\sphinxupquote{Boot Selection}} masukkan \sphinxstylestrong{ISO OSGeo Live} yang sudah diunduh sebelumnya. Biarkan opsi lain dengan pengaturan \sphinxstyleemphasis{default}, kemudian klik \sphinxcode{\sphinxupquote{Start}}.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[height=350\sphinxpxdimen]{{2020-12-07-19-55-11}.png}
\end{figure}

\item {} 
Setelah proses selesai, lakukan restart Komputer. Pastikan bahwa Laptop atau Komputer Anda menggunakan USB sebagai \sphinxhref{https://neosmart.net/wiki/boot-usb-drive/}{prioritas Boot pertama}. Pengaturan untuk ini dilakukan melalui BIOS, dan memiliki bentuk yang berbeda untuk tiap jenis BIOS. Pengaturan ini biasanya dapat dijumpai pada menu \sphinxstylestrong{Boot Priority}. Silahkan mengacu pada dokumentasi tiap BIOS untuk penjelasan lebih lanjut.

\sphinxincludegraphics{{2020-12-07-20-26-38}.png}

\item {} 
Tunggu sampai GRUB (Boot Manager Linux) memanggil OSGeo. Setelah selesai, Linux akan dimulai. Gunakan OSGeo Live seperti menggunakan sistem operasi seperti biasa
\sphinxincludegraphics{{2020-12-07-18-26-15}.png}

\end{enumerate}

Terdapat banyak perangkat lunak FOSS\sphinxhyphen{}GIS pada OSGeo Live, baik yang berupa aplikasi maupun library seperti Geopandas. OSGeo Live memungkinkan kita untuk mencoba aplikasi tersebut tanpa perlu menginstall apapun pada komputer kita.

 


\subsection{Menggunakan Perangkat Lunak OpenSource untuk GIS}
\label{\detokenize{sesi1/fossgis:menggunakan-perangkat-lunak-opensource-untuk-gis}}
Sepanjang bagian ini kita telah membahas beberapa aspek penggunaan perangkat lunak FOSS\sphinxhyphen{}GIS, seperti biaya yang rendah, pengembangan fitur dan rilis yang terjadwal, banyaknya pilihan yang dapat digunakan, komunitas yang aktif, serta berbagai organisasi yang mengatur standarisasi dan dukungan penuh pada pengembangan aplikasi GIS berbasis open source. Meskipun demikian, penggunaan perangkat FOSS\sphinxhyphen{}GIS di Indonesia sendiri tergolong masih rendah. Salah satu sebabnya adalah kepercayaan terhadap perangkat berbiaya rendah (atau gratis) masih kurang, disamping juga kurangnya SDM yang mampu mengembangkan dan mengadopsi penggunaan perangkat lunak FOSS\sphinxhyphen{}GIS di berbagai bidang.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-07-13-09-54}.png}
\caption{Keuntungan dari adopsi perangkat lunak Open Source (Sumber Gambar: Shin (2014))}\label{\detokenize{sesi1/fossgis:adopsi}}\end{figure}

Pengembangan perangkat lunak open source pada berbagai instansi sebenarnya dapat lebih menguntungkan dalam jangka panjang dibandingkan dengan penggunaan perangkat lunak berbayar. Penggunaan perangkat lunak Open source mungkin membutuhkan kemampuan dan kurva belajar yang cukup terjal, tetapi dengan pelatihan dan pengembangan secara terus\sphinxhyphen{}menerus, pada gilirannya instansi akan berkembang dengan sendirinya, karena berbagai masalah pada perangkat lunak akan dapat diselesaikan sendiri. Selain itu, dukungan komunitas baik lokal maupun internasional untuk perangkat lunak open source dapat dijumpai dengan mudah. Terakhir, lembaga pemerintah maupun swasta dapat ‘memesan’ fitur tertentu pada perangkat lunak Open Source dengan menjadi sponsor pengembangan fitur yang diminta, sehingga disamping memperoleh keuntungan untuk lembaga itu sendiri, dengan sendirinya juga berkontribusi pada komunitas dan masyarakat umum.

Disamping itu, penggunaan perangkat lunak open source menjamin dukungan pada standar yang didukung secara internasional. Hal ini terutama diperlukan seiring dengan kebijakan satu peta yang sedang didorong oleh pemerintah, dimana tiap wali data memiliki kewajiban untuk menyediakan infrastruktur berbagi\sphinxhyphen{}pakai data geospasial. Penggunaan perangkat lunak open source akan menjamin interoperabilitas (misalnya melalui standar OGC), dan menghindari \sphinxstyleemphasis{vendor lock} pada beberapa perangkat lunak tertentu.


\chapter{Pengantar Basisdata Relational}
\label{\detokenize{sesi2/intrordbms:pengantar-basisdata-relational}}\label{\detokenize{sesi2/intrordbms::doc}}
Basisdata merupakan salah satu elemen penting pada aplikasi Enterprise GIS. Dengan basisdata, sebuah sistem dapat didesain untuk digunakan oleh multi\sphinxhyphen{}user, dengan hak akses untuk tiap pengguna yang berbeda\sphinxhyphen{}beda. Demikian pula, basisdata memungkinkan data dalam jumlah besar untuk disimpan pada satu lokasi penyimpanan yang aman, memungkinkan analisis data secara cepat serta menjamin keselamatan data apabila terjadi masalah pada data tersebut.

Bagian ini membahas mengenai:

 {\hyperref[\detokenize{sesi2/relationaldb::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Pengantar mengenai Basisdata Relational}}}}
: Konsep basisdata relational serta instalasi basisdata PostgreSQL dan PostGIS dengan menggunakan Docker

 {\hyperref[\detokenize{sesi2/dbmanagement::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Administrasi pengguna pada Basisdata}}}}
: Penjelasan tentang pengaturan multi\sphinxhyphen{}user pada Basisdata PostgreSQL (User, Roles dan Priviledges)

 {\hyperref[\detokenize{sesi2/postgisquery::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Basisdata Spasial dengan PostGIS}}}}
: Bagaimana menggunakan ekstensi PostGIS untuk menginput data spasial, melakukan analisis serta visualisasi data spasial dan menghubungkan basisdata dengan QGIS






\section{Basisdata Relational}
\label{\detokenize{sesi2/relationaldb:basisdata-relational}}\label{\detokenize{sesi2/relationaldb::doc}}
Basisdata relational merupakan salah satu model basisdata pada DBMS (Database Management System). Model Relasional banyak digunakan sejak tahun 90an hingga saat ini karena berbagai kelebihannya dalam memanajemen data dalam jumlah besar. Pada bagian ini akan dibahas mengenai basisdata relasional, khususnya PostgreSQL.


\subsection{Pemodelan data pada Basisdata Relasional}
\label{\detokenize{sesi2/relationaldb:pemodelan-data-pada-basisdata-relasional}}
Kita ambil sebuah contoh untuk kasus penanggulangan kebencanaan: anda ditugaskan oleh pimpinan anda untuk melakukan inventarisasi data yang diperoleh dari hasil pemetaan akibat bencana banjir di suatu daerah. Anda misalnya berurusan dengan data\sphinxhyphen{}data jumlah pengungsi dari masing\sphinxhyphen{}masing desa, kerusakan pada tiap desa, lokasi kantung\sphinxhyphen{}kantung pengungsian, kebutuhan tiap kepala, dan lain sebagainya. Apabila dinyatakan dalam bentuk tabel, data\sphinxhyphen{}data tersebut mungkin tampak seperti berikut:

\sphinxincludegraphics{{2020-12-03-08-07-09}.png}

\sphinxincludegraphics{{2020-12-03-08-07-21}.png}

Apabila suatu ketika Anda ditanya, ‘\sphinxstyleemphasis{Dari mana saja asal pengungsi di Posko A}?’, apa jawaban yang akan anda berikan? Apa yang akan anda lakukan untuk memperoleh jawaban yang diinginkan?	
Pertama\sphinxhyphen{}tama, Anda mungkin akan melihat pada masing\sphinxhyphen{}masing tabel, kemudian mencari informasi yang sesuai pada tiap tabel tersebut. Tentunya hal ini mudah dilakukan apabila data yang disediakan cukup sedikit. Bagaimana jika data yang ada berjumlah ratusan atau bahkan mungkin ribuan data?

Di sinilah peranan \sphinxstylestrong{Basisdata}. Sebuah sistem basisdata menghubungkan kumpulan data menjadi sebuah sistem yang terintegrasi. Dapat dikatakan, basisdata merupakan kumpulan dari tabel\sphinxhyphen{}tabel yang saling terhubung. Dengan menggunakan basisdata, Anda dapat mengambil data dari suatu tabel berdasarkan data dari tabel yang lain.

Gambaran umum sebuah basisdata adalah \sphinxstyleemphasis{sekumpulan tabel yang saling terhubung}. Hubungan antar tabel ini dapat dilakukan dengan berbagai macam cara. Salah satunya adalah dengan menggunakan cara yang Anda lihat pada contoh tabel\sphinxhyphen{}tabel di atas.


\subsection{Pengantar Basisdata Relational}
\label{\detokenize{sesi2/relationaldb:pengantar-basisdata-relational}}
\sphinxstylestrong{Sistem Manajemen Basis Data Relasional} (RDBMS) adalah kumpulan program dan fungsi berbasis tabel yang menyediakan antarmuka antara pengguna dan aplikasi dan basis data, memberikan cara sistematis untuk membuat, memperbarui, menghapus, mengelola, dan mengambil data. Sebagian besar sistem manajemen database relasional menggunakan bahasa pemrograman SQL untuk mengakses database dan banyak yang mengikuti properti \sphinxstyleemphasis{ACID (Atomicity, Consistency, Isolation, Durability)} dari database:
\begin{itemize}
\item {} 
\sphinxstylestrong{Atomicity}: Jika ada pernyataan dalam transaksi yang gagal, seluruh transaksi gagal dan database dibiarkan tidak berubah.

\item {} 
\sphinxstylestrong{Consistency}: Transaksi harus memenuhi semua protokol yang ditentukan oleh sistem \sphinxhyphen{} tidak ada transaksi yang diselesaikan sebagian.

\item {} 
\sphinxstylestrong{Isolation}: Tidak ada transaksi yang memiliki akses ke transaksi lain yang belum selesai. Setiap transaksi bersifat independen.

\item {} 
\sphinxstylestrong{Durability}: Setelah transaksi dilakukan, transaksi akan tetap dilakukan melalui penggunaan log transaksi dan cadangan.

\end{itemize}

c

Basisdata relasional menyimpan data (entitas dunia nyata) dalam bentuk tabel serta menyediakan cara yang efisien, intuitif, dan fleksibel untuk menyimpan dan mengakses informasi pada tabel tersebut secara terstruktur. Tabel pada basisdata relasional juga dikenal sebagai \sphinxstylestrong{relasi}, terdiri dari kolom yang berisi satu atau lebih kategori data; dan baris, juga dikenal sebagai \sphinxstyleemphasis{record}, berisi sekumpulan data yang ditentukan oleh kategori.

Aplikasi Database Management System/DBMS (seperti PostgreSQL) mengakses data dengan menentukan \sphinxstylestrong{kueri}, yang menggunakan operasi untuk mengidentifikasi atribut, memilih \sphinxstyleemphasis{tuples}, dan menentukan relasi pada data. Model relasional untuk manajemen basis data dikembangkan oleh ilmuwan komputer IBM Edgar F. Codd pada tahun 1970.


\subsubsection{Beberapa istilah pada Basisdata Relasional}
\label{\detokenize{sesi2/relationaldb:beberapa-istilah-pada-basisdata-relasional}}
Sebagai review, berikut adalah beberapa istilah yang dikenal pada basisdata relasional:
\begin{itemize}
\item {} 
\sphinxstylestrong{Tabel}: Merupakan struktur penyimpanan dasar dari basis data objek relasional, terdiri dari satu atau lebih kolom (column) dan nol atau lebih baris (row).

\item {} 
\sphinxstylestrong{Row (baris)}: Baris merupakan kombinasi dari nilai\sphinxhyphen{}nilai kolom dalam tabel; sebagai contoh, informasi tentang suatu departemen pada tabel ‘Departemen’. Baris seringkali disebut dengan record atau tuple.

\item {} 
\sphinxstylestrong{Column (kolom)}: Kolom menggambarkan jenis data pada tabel; Kolom di definisikan dengan nama kolom dan tipe data beserta panjang data tertentu.

\item {} 
\sphinxstylestrong{Field}: Field merupakan pertemuan antara baris dan kolom. Sebuah field menggambarkan satu keterangan mengenai data. Jika pada suatu field tidak terdapat data, maka field tersebut dikatakan memiliki nilai “null” atau kosong.

\item {} 
\sphinxstylestrong{Primary key}: Primary key atau kunci utama merupakan kolom atau kumpulan kolom yang secara unik membedakan antara baris yang satu dengan lainnya; Kolom yang merupakan primary key ini tidak boleh mengandung nilai “null”, dan nilainya harus unik (berbeda antara baris satu dengan lainnya).

\item {} 
\sphinxstylestrong{Foreign key}: Foreign key atau kunci tamu merupakan kolom atau kumpulan kolom yang mengacu ke primary key pada tabel yang sama atau tabel lain. Foreign key ini dibuat untuk memaksakan aturan\sphinxhyphen{}aturan relasi pada basis data. Nilai data dari foreign key harus sesuai dengan nilai data pada kolom dari tabel yang diacunya atau bernilai “null”.

\item {} 
\sphinxstylestrong{Relasi} merupakan interaksi antara tabel yang menunjukkan hubungan antara objek\sphinxhyphen{}objek yang ada di dunia nyata. Relasi menyatakan hubungan antar tabel sebagai model dari dunia nyata.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-03-06-57-27}.png}
\caption{Tabel atau relasi pada Basisdata Relational}\label{\detokenize{sesi2/relationaldb:table}}\end{figure}


\subsubsection{Relasi pada basisdata relasional}
\label{\detokenize{sesi2/relationaldb:relasi-pada-basisdata-relasional}}
Jika kita pahami bahwa entitas dunia nyata dimodelkan sebagai sebuah \sphinxstylestrong{relasi} (atau tabel) pada basisdata relasional, maka hubungan antar entitas tersebut di dunia nyata juga dapat kita modelkan. Pada sebuah basisdata relasional, hubungan antar entitas dapat disederhanakan menjadi tiga bentuk saja: One to One, One to Many dan Many to Many. Berikut adalah model relasi pada sebuah basisdata relasional%
\begin{footnote}[1]\sphinxAtStartFootnote
https://aantamim.id/relasi\sphinxhyphen{}tabel\sphinxhyphen{}database/
%
\end{footnote} tersebut:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstylestrong{One to One (1 to 1)}
Relasi database model ini terjadi apalabila sebuah data terdapat pada 2 buah tabel, dan hanya diperbolehkan satu data saja pada masing masing tabel (\sphinxstyleemphasis{unique record}), sama halnya seperti \sphinxstyleemphasis{primary key}, record yang ada pada model ini tidak boleh ada yang sama.

\sphinxincludegraphics{{2020-12-03-08-08-58}.png}

Dalam bentuk tabel relasional, hasilnya adalah seperti ini:

\sphinxincludegraphics{{2020-12-07-23-39-22}.png}

\item {} 
\sphinxstylestrong{One to Many (1 to n)}
Relasi database model  ini membolehkan data yang sama pada tabel kedua, tapi hanya membolehkan data yang bersifat unique (unik) pada tabel pertama. Jadi pada model tabel kedua boleh memiliki beberapa data yang sama.
\sphinxincludegraphics{{2020-12-03-08-10-30}.png}

Dalam bentuk tabel:
\sphinxincludegraphics{{2020-12-03-08-09-58}.png}

\item {} 
\sphinxstylestrong{Many to many (n to m)}
Berbeda dengan kedua model diatas, relasi database model ini membolehkan beberapa data yang sama baik pada tabel pertama maupun tabel kedua. Dengan demikian tidak ada unique record di kedua tabel tersebut.
\sphinxincludegraphics{{2020-12-03-08-11-05}.png}

Dalam bentuk tabel:
\sphinxincludegraphics{{2020-12-03-08-11-15}.png}

\end{enumerate}

Apabila kita gambarkan hubungan yang kompleks antar semua entitas pada basisdata, kita akan memperoleh sebuah diagram yang disebut dengan \sphinxstylestrong{Diagram Entity Relationship (Diagram ER)}.


\subsubsection{Operasi pada Basisdata Relasional}
\label{\detokenize{sesi2/relationaldb:operasi-pada-basisdata-relasional}}
Apabila kita menganggap basisdata sebagai sebuah kumpulan dari entitas yang saling terhubung, maka seperti halnya sebuah bilangan matematika, kita dapat menggunakan berbagai operasi pada entitas ini untuk memperoleh jawaban dari pertanyaan yang kita ajukan. Codd sendiri awalnya mendefinisikan delapan operasi berbeda, yang kemudian disebut dengan \sphinxhref{https://www.geeksforgeeks.org/introduction-of-relational-algebra-in-dbms/}{Relational Algebra}. Relational Algebra merupakan bahasa prosedural yang menggunakan operator \sphinxstyleemphasis{unary} atau \sphinxstyleemphasis{binary} pada relasi atau tabel. Hasil dari Aljabar relasional ini adalah sebuah tabel lain yang menggambarkan hubungan dari kedua entitas.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-08-00-41-03}.png}
\caption{Relational Algebra pada Basisdata Relational}\label{\detokenize{sesi2/relationaldb:relag}}\end{figure}

Pada sebuah RDBMS, operasi aljabar relasional ini diwujudkan menggunakan bahasa SQL, seperti yang akan dibahas sebagai berikut.


\subsection{Structured Query Language (SQL)}
\label{\detokenize{sesi2/relationaldb:structured-query-language-sql}}
Apabila Anda menggunakan komputer untuk membuat basisdata pada contoh di awal bab ini, Anda akan dengan cepat menjawab pertanyaan yang diajukan sebelumnya. Apabila Anda mencari: ‘\sphinxstyleemphasis{Darimana saja asal pengungsi di posko A}?’, maka komputer akan langsung melihat tabel \sphinxstylestrong{Posko Pengungsi} untuk melihat nomor identifikasi masing\sphinxhyphen{}masing posko pengungsian, kemudian mencocokkannya dengan tabel **Asal Pengungsi **untuk melihat Desa apa saja yang ada di sana. Sekarang, bagaimana kita menanyakan pertanyaan seperti ini kepada komputer?

Bagaimana kita membuat suatu sistem basisdata dan mengajukan pertanyaan (pertanyaan=‘QUERY’) kepada komputer agar kita memperoleh data yang kita inginkan? Untuk itulah kita akan mempelajari mengenai bahasa \sphinxstylestrong{SQL (Structured Query Language)}. Bahasa inilah yang akan kita gunakan untuk ‘bertanya’ atau mengajukan ‘query’ kepada komputer. Kita juga menggunakan bahasa SQL untuk menyelesaikan berbagai macam operasi pada aljabar relasional yang kita gunakan untuk mendapatkan jawaban dari pertanyaan yang kita inginkan.


\subsubsection{Bahasa SQL}
\label{\detokenize{sesi2/relationaldb:bahasa-sql}}
\sphinxstylestrong{SQL} merupakan serangkaian perintah yang kita gunakan untuk membuat dan melakukan manajemen terhadap suatu basisdata di komputer. Misalnya, untuk membuat sebuah tabel seperti ini:

\sphinxincludegraphics{{2020-12-03-08-18-49}.png}

Dalam bahasa SQL akan tertulis seperti ini:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{Anggota} 
	\PYG{p}{(}
	\PYG{n}{No\PYGZus{}id} \PYG{n+nb}{INTEGER} \PYG{k}{NOT} \PYG{k}{NULL}\PYG{p}{,}
	\PYG{n}{nama} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
	\PYG{n}{jenis\PYGZus{}kelamin} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
	\PYG{p}{)}\PYG{p}{;}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{anggota} \PYG{k}{VALUES} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}21451\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Budi Darmawan\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}L\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{anggota} \PYG{k}{VALUES} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}21569\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Anggi Lestari\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}P\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{anggota} \PYG{k}{VALUES} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}21584\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Joko Anantoko\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}L\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{PRIMARY} \PYG{k}{KEY} \PYG{n}{no\PYGZus{}id}\PYG{p}{;}
\end{sphinxVerbatim}

Berikut adalah penjelasan beberapa perintah dasar di atas:

 

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{Anggota} \PYG{p}{(}
\end{sphinxVerbatim}

 
\begin{itemize}
\item {} 
\sphinxstylestrong{CREATE TABLE}  Fungsi dari perintah ini adalah untuk membuat sebuah tabel baru, yang tentu saja isinya masih kosong. Untuk mengisi tabel yang baru dibuat ini kita gunakan perintah INSERT INTO dan VALUES seperti yang akan dijelaskan di bawah.

\item {} 
\sphinxstylestrong{Anggota}  Adalah nama/judul dari tabel pertama yang akan kita buat pada basisdata ini. Judul tabel ini merupakan variable, artinya, Anda dapat menggunakan nama apapun yang Anda inginkan, asalkan merupakan satu buah kata (kita lihat, tanda spasi pada kata\sphinxhyphen{}kata ‘bidang tanah’ diganti dengan tanda underscore/garis bawah. Ini untuk menjaga variable tersebut hanya merupakan satu kata).

\end{itemize}

 

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{n}{No\PYGZus{}id} \PYG{n+nb}{INTEGER} \PYG{k}{NOT} \PYG{k}{NULL}\PYG{p}{,}
 \PYG{n}{nama} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
 \PYG{n}{jenis\PYGZus{}kelamin} \PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

 
\begin{itemize}
\item {} 
\sphinxstylestrong{No\_id, Nama dan Jenis\_kelamin}  No\_id merupakan nama kolom pertama yang kita isikan (lihat tabel pada contoh di atas agar lebih jelas). No\_id ini adalah kolom yang akan kita fungsikan untuk memuat identitas unik masing\sphinxhyphen{}masing orang. Demikian pula, Nama dan Jenis\_kelamin merupakan nama\sphinxhyphen{}nama kolom yang kita buat pada tabel anggota yang akan kita isi dengan keterangan\sphinxhyphen{}keterangan yang kita inginkan.

\item {} 
\sphinxstylestrong{Tipe Data}  INTEGER dan VARCHAR yang anda gunakan pada baris\sphinxhyphen{}baris perintah tadi berfungsi untuk menjelaskan tipe data dari kolom yang Anda buat. Berikut beberapa tipe data yang dapat anda gunakan:
\begin{itemize}
\item {} 
INTEGER		: Menyatakan data berupa bilangan bulat. Panjang data yang dapat dimuat adalah antara \sphinxhyphen{}2147483648 sampai 2147483647.

\item {} 
FLOAT		: Menyatakan data berupa bilangan desimal

\item {} 
VARCHAR	: Menyatakan sembarang karakter (huruf, angka, atau karakter yang lain). Apabila anda menambahkan bilangan dalam tanda kurung di belakangnya, misalnya VARCHAR(2), artinya anda membatasi maksimal hanya 2 karakter yang akan ditampilkan, tidak boleh lebih.

\item {} 
TEXT		: Menampilkan baris teks. Bedanya dengan tipe data character adalah panjang data yang bisa ditampung. Anda bisa memasukkan beberapa baris kalimat pada tipe data ini.

\item {} 
DATE		: Memasukkan tanggal ke dalam kolom

\item {} 
BOOLEAN	: Apabila anda memilih tipe data ini untuk sebuah kolom, artinya kolom tersebut hanya bisa memliki dua macam nilai: ‘TRUE’ atau ‘FALSE’. Biasanya tipe data ini digunakan untuk menyatakan pilihan.
Perhatikan bahwa tiap kali anda membuat sebuah kolom, anda harus memisahkannya dengan baris perintah selanjutnya menggunakan tanda koma (,). Ini adalah salah satu aturan penulisan pada bahasa SQL.

\end{itemize}

\end{itemize}

 

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{PRIMARY} \PYG{k}{KEY} \PYG{n}{no\PYGZus{}id}\PYG{p}{;}
\end{sphinxVerbatim}

 
\begin{itemize}
\item {} 
\sphinxstylestrong{PRIMARY KEY}  Pada baris perintah ini, kita memberi tahu komputer bahwa kolom No\_id akan kita jadikan sebagai PRIMARY KEY. Primary key adalah kolom yang akan kita gunakan sebagai penghubung dengan tabel lain. Dalam hal ini, data yang berada pada kolom no\_id haruslah bersifat unik. Artinya, data\sphinxhyphen{}data pada kolom ini harus berbeda antara satu dengan yang lainnya.

\end{itemize}


\subsubsection{Menggunakan Query untuk menanyakan pertanyaan pada Basisdata}
\label{\detokenize{sesi2/relationaldb:menggunakan-query-untuk-menanyakan-pertanyaan-pada-basisdata}}
Di atas kita telah melihat penjelasan bagaimana bahasa SQL digunakan untuk membuat sebuah tabel baru. Pada bagian ini kita akan menanyakan beberapa pertanyaan pada tabel tersebut.

Sekarang, dengan menggunakan tabel \sphinxcode{\sphinxupquote{anggota}} di atas sebagai acuan, kita dapat menanyakan pertanyaan berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{anggota}
\end{sphinxVerbatim}

SELECT dan FROM pada baris perintah di atas digunakan untuk menampilkan isi dari tabel yang dipanggil (pada contoh adalah tabel \sphinxcode{\sphinxupquote{anggota}}). Tanda asterisk (*) di atas digunakan untuk menampilkan keseluruhan data pada semua kolom di tabel tersebut. Apabila anda memanggil perintah tersebut pada sebuah perangkat lunak basisdata (seperti PostgreSQL yang akan kita pelajari nanti), maka perintah tersebut akan menampilkan seluruh isi tabel anggota.

Perintah tersebut akan menampilkan semua isi kolom nama pada tabel anggota, seperti berikut:

\sphinxincludegraphics{{2020-12-03-08-22-22}.png}

Apabila anda hanya ingin menampilkan satu baris tertentu, Anda dapat menggunakan perintah WHERE:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{anggota} \PYG{k}{WHERE} \PYG{n}{No\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{21451}
\end{sphinxVerbatim}

hasilnya:

\sphinxincludegraphics{{2020-12-03-08-23-12}.png}

Apa keluaran dari bahasa SQL berikut?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT nama FROM anggota WHERE jenis\PYGZus{}kelamin = ‘L’
\end{sphinxVerbatim}

Sebuah perintah SQL dapat menjadi sangat kompleks: semakin rumit informasi yang ingin kita peroleh, semakin banyak relasi yang terlibat, maka akan semakin rumit pula Query yang harus kita ajukan. Meskipun demikian, SQL dapat memperoleh informasi yang cukup rumit hanya dengan beberapa perintah sederhana, sehingga sangat ideal untuk keperluan analisis data dalam jumlah besar, khususnya data spasial.


\subsubsection{DDL, DML, DCL dan TCL}
\label{\detokenize{sesi2/relationaldb:ddl-dml-dcl-dan-tcl}}
Kita telah melihat beberapa perintah SQL yang dapat digunakan untuk ‘bertanya’ pada basisdata menggunakan Query tertentu. Perintah (\sphinxstyleemphasis{command}) dalam bahasa SQL seperti yang disebutkan di atas dapat dikelompokkan menjadi empat kelompok besar: \sphinxstyleemphasis{Data Definition Language} (DDL), \sphinxstyleemphasis{Data Manipulation Language} (DML), \sphinxstyleemphasis{Data Control Language} (DCL) dan \sphinxstyleemphasis{Transaction Control Language} (TCL). Keempat jenis perintah ini membagi bahasa SQL ke dalam jenis operasi yang dilakukan:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-08-00-54-04}.png}
\caption{Perintah dalam bahasa SQL}\label{\detokenize{sesi2/relationaldb:ddl}}\end{figure}

Berikut penjelasan untuk tiap operasi:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Data Definition Language} (DDL)

Perintah yang dikelompokkan sebagai DDL digunakan pada saat pembuatan skema dan pendefinisian basisdata, serta bagaimana data disimpan pada basidata.
\begin{itemize}
\item {} 
CREATE \sphinxhyphen{} Digunakan untuk membuat basisdata baru serta objek\sphinxhyphen{}objek yang terdapat di dalamnya (TABLE, INDEX, VIEW, FUNCTION, dan sebagainya)

\item {} 
ALTER \sphinxhyphen{} Merubah struktur basidata dan objek di dalamnya

\item {} 
DROP \sphinxhyphen{} Menghapus basisdata atau objek di dalamnya

\item {} 
TRUNCATE \sphinxhyphen{} Menghapus semua \sphinxstyleemphasis{record} pada basisdata

\item {} 
RENAME \sphinxhyphen{} Mengganti nama sebuah objek basisdata

\end{itemize}

\item {} 
\sphinxstyleemphasis{Data Manipulation Language} (DML)

DML terdiri dari sebagian besar perintah yang kita gunakan pada sebuah basisdata. DML berkaitan dengan manipulasi data dan objek pada basisdata, termasuk untuk menyimpan, memodifikasi, mengambil data, menghapus dan memperbarui data pada basisdata.
\begin{itemize}
\item {} 
SELECT \sphinxhyphen{} Digunakan untuk memilih dan mengambil data dari basisdata berdasarkan kriteria tertentu

\item {} 
INSERT \sphinxhyphen{} Digunakan untuk memasukkan data ke dalam relasi

\item {} 
UPDATE \sphinxhyphen{} Memungkinkan pengubahan nilai dari beberapa atribut dalam tupel yang ada.

\item {} 
DELETE \sphinxhyphen{} Digunakan untuk menghapus tupel dari tabel.

\item {} 
MERGE \sphinxhyphen{} Menggabungkan data baru pada data yang sudah ada

\end{itemize}

Penggunaan tiap perintah di atas akan dikontrol oleh CONSTRAINT yang telah ditetapkan pada relasi atau basisdata tersebut. Contoh konstrain yang diterapkan pada basisdata adalah pembatasan tipe data pada kolom sebuah tabel.

Berikut adalah contoh dari penggunaan perintah DML:

\sphinxstylestrong{Insert Operation}

Operasi Insert menambahkan data baru pada sebuah tabel sesuai dengan kolom yang tersedia

\sphinxincludegraphics{{2020-12-03-07-21-13}.png}

\sphinxstylestrong{Update Operation}

Pada tabel di bawah, status \sphinxcode{\sphinxupquote{CustomerName=Apple}} berubah dari \sphinxcode{\sphinxupquote{inactive}} menjadi \sphinxcode{\sphinxupquote{active}}

\sphinxincludegraphics{{2020-12-03-07-21-29}.png}

\sphinxstylestrong{Delete Operation}
Pada operasi penghapusan, suatu kriteria diberikan melalui Query untuk
\sphinxincludegraphics{{2020-12-03-07-21-44}.png}

\sphinxstylestrong{Select Operation}

Operasi berikut memilih Customer dengan nama “Amazon”
\sphinxincludegraphics{{2020-12-03-07-22-43}.png}

\item {} 
\sphinxstyleemphasis{Data Control Language} (DCL)

Perintah pada DCL sebagian besar terkait dengan pemberian hak, permission, dan pengaturan kontrol lain pada basisdata.
\begin{itemize}
\item {} 
GRANT \sphinxhyphen{} Memberikan hak dan izin (\sphinxstyleemphasis{Priviledges}) kepada pengguna untuk mengakses sebuah basisdat

\item {} 
REVOKE \sphinxhyphen{} Menghilangkan hak pada pengguna

\end{itemize}

\item {} 
\sphinxstyleemphasis{Transaction Control Language} (TCL)

TCL digunakan untuk mengatur transaksi pada sebuah basisdata, yaitu:
\begin{itemize}
\item {} 
COMMIT \sphinxhyphen{} menyimpan operasi transaksi

\item {} 
ROLLBACK \sphinxhyphen{} kembali pada rekaman transaksi sebelumnya pada saat terjadi kesalahan

\item {} 
SET TRANSACTION \sphinxhyphen{} mendefinisikan karakteristik transaksi

\end{itemize}

\end{itemize}

Setelah ini, kita akan menggunakan PostgreSQL untuk melakukan Query menggunakan Bahasa SQL. Terlebih dahulu lakukan instalasi sesuai dengan panduan yang diberikan sebagai berikut.


\subsection{Instalasi dan Pengaturan Basisdata PostgreSQL}
\label{\detokenize{sesi2/relationaldb:instalasi-dan-pengaturan-basisdata-postgresql}}
PostgreSQL merupakan perangkat lunak yang digunakan untuk melakukan manajemen basisdata, sedangkan PostGIS merupakan perangkat lunak tambahan (‘Plugin’) pada PostgreSQL yang digunakan untuk menambahkan fungsi keruangan (spasial) pada PostgreSQL. Pada bagian ini diuraikan cara membuat basisdata dengan menggunakan PostgreSQL/PostGIS, dengan lebih dahulu membahas mengenai instalasi PostgreSQL dan PostGIS menggunakan Docker.


\subsubsection{Latihan: Instalasi dan Pengaturan Docker}
\label{\detokenize{sesi2/relationaldb:latihan-instalasi-dan-pengaturan-docker}}
Pada latihan ini akan dibahas mengenai instalasi Docker. Docker nantinya akan kita gunakan sebagai Container untuk mempermudah instalasi PostgreSQL dan PostGIS. Arsitektur Docker adalah sebagai berikut:

\sphinxincludegraphics{{2020-12-03-08-27-49}.png}

Langkah berikut merujuk pada \sphinxhref{https://docs.docker.com/engine/install/ubuntu/}{Panduan Resmi Instalasi Docker}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Lakukan update, kemudian lakukan instalasi beberapa dependencies untuk Docker

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get install \PYG{l+s+se}{\PYGZbs{}}
 apt\PYGZhy{}transport\PYGZhy{}https \PYG{l+s+se}{\PYGZbs{}}
 ca\PYGZhy{}certificates \PYG{l+s+se}{\PYGZbs{}}
 curl \PYG{l+s+se}{\PYGZbs{}}
 gnupg\PYGZhy{}agent \PYG{l+s+se}{\PYGZbs{}}
 software\PYGZhy{}properties\PYGZhy{}common
\end{sphinxVerbatim}

\item {} 
Tambahkan GPG official untuk Docker:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
curl \PYGZhy{}fsSL https://download.docker.com/linux/ubuntu/gpg \PYG{p}{|} sudo apt\PYGZhy{}key add \PYGZhy{}
\end{sphinxVerbatim}

\item {} 
Periksa  fingerprint untuk GPG yang telah ditambahkan ke Ubuntu

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}key fingerprint 0EBFCD88
\end{sphinxVerbatim}

\item {} 
Tambahkan repository baru. Docker memiliki repository tersendiri sehingga perlu memberi tahu apt untuk mengambil instalasi dari repository ini:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo add\PYGZhy{}apt\PYGZhy{}repository \PYG{l+s+se}{\PYGZbs{}}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{deb [arch=amd64] https://download.docker.com/linux/ubuntu \PYGZbs{}}
\PYG{l+s+s2}{ }\PYG{k}{\PYGZdl{}(}lsb\PYGZus{}release \PYGZhy{}cs\PYG{k}{)}\PYG{l+s+s2}{ \PYGZbs{}}
\PYG{l+s+s2}{ stable}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
Update kembali apt:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get update
sudo apt\PYGZhy{}get install docker\PYGZhy{}ce docker\PYGZhy{}ce\PYGZhy{}cli containerd.io
\end{sphinxVerbatim}

\item {} 
Uji apakah docker sudah berhasil diinstall

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo docker run hello\PYGZhy{}world
\end{sphinxVerbatim}

\item {} 
Memasukkan user ke dalam grup \sphinxcode{\sphinxupquote{docker}}. \sphinxhref{https://docs.docker.com/engine/install/linux-postinstall/\#manage-docker-as-a-non-root-user}{Langkah ini} perlu untuk menghilangkan \sphinxcode{\sphinxupquote{sudo}} pada perintah untuk memanggil docker.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo usermod \PYGZhy{}aG docker \PYG{n+nv}{\PYGZdl{}USER}
newgrp docker 
\end{sphinxVerbatim}

\end{enumerate}

\begin{sphinxadmonition}{note}{Catatan}

Docker memerlukan Systemd untuk menjalankan servicenya, sama seperti Tomcat pada materi sebelumnya. Untuk itu, apabila muncul pesan kesalahan terkait \sphinxcode{\sphinxupquote{systemd}} atau \sphinxcode{\sphinxupquote{systemctl}} pada WSL, coba kembali langkah\sphinxhyphen{}langkah untuk mengkoreksi system seperti yang telah disebutkan sebelumnya.
\end{sphinxadmonition}

Setelah instalasi Docker berhasil, selanjutnya adalah menggunakan Docker untuk melakukan instalasi Image untuk PostGIS. Image adalah paket aplikasi yang dibuat oleh developer untuk memuat serangkaian perintah dan dapat diduplikasi oleh siapapun yang menghendaki. Image pada Docker tersimpan pada Docker Hub sebagai satu repository tempat Image dibagikan:

\sphinxincludegraphics{{2020-12-03-08-36-24}.png}


\subsubsection{Latihan: Memulai Docker untuk PostGIS}
\label{\detokenize{sesi2/relationaldb:latihan-memulai-docker-untuk-postgis}}
Untuk keperluan latihan ini kita akan menggunakan Image PostGIS yang dibuat oleh \sphinxhref{https://github.com/kartoza/docker-postgis}{Kartoza}. Sebenarnya, terdapat banyak Image yang sudah dibuat oleh banyak developer. Kita dapat mencari Image terkait PostGIS menggunakan perintah ‘search’ pada Docker:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker search postgis
\end{sphinxVerbatim}

hasilnya:

\sphinxincludegraphics{{2020-12-03-08-39-33}.png}

Image PostGIS yang dibuat oleh tim Kartoza dapat dijumpai pada Docker Hub sebagai berikut:
https://hub.docker.com/r/kartoza/postgis/

Berikut adalah langkah instalasi Image PostGIS dengan Docker %
\begin{footnote}[2]\sphinxAtStartFootnote
https://alexurquhart.com/post/set\sphinxhyphen{}up\sphinxhyphen{}postgis\sphinxhyphen{}with\sphinxhyphen{}docker/
%
\end{footnote}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Membuat Persistance Volume.
Persistance Volume digunakan agar Docker menyimpan berkas pada lokasi yang dapat diakses, yaitu pada mesin WSL. Berikut perintahnya:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker volume create pg\PYGZus{}data
\end{sphinxVerbatim}

\item {} 
Untuk menginstall PostGIS kita gunakan perintah berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker run \PYGZhy{}\PYGZhy{}name\PYG{o}{=}postgis \PYGZhy{}d \PYGZhy{}e \PYG{n+nv}{POSTGRES\PYGZus{}USER}\PYG{o}{=}postgres \PYGZhy{}e \PYG{n+nv}{POSTGRES\PYGZus{}PASS}\PYG{o}{=}postgres \PYGZhy{}e \PYG{n+nv}{POSTGRES\PYGZus{}DBNAME}\PYG{o}{=}gis \PYGZhy{}e \PYG{n+nv}{ALLOW\PYGZus{}IP\PYGZus{}RANGE}\PYG{o}{=}\PYG{l+m}{0}.0.0.0/0 \PYGZhy{}p \PYG{l+m}{5432}:5432 \PYGZhy{}v pg\PYGZus{}data:/var/lib/postgresql \PYGZhy{}\PYGZhy{}restart\PYG{o}{=}always kartoza/postgis:13.0
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
docker run –name = postgis memberi tahu Docker bahwa container baru kami akan diberi nama postgis

\item {} 
\sphinxhyphen{}d menjalankan kontainer di latar belakang (mode terpisah)

\item {} 
\sphinxhyphen{}e POSTGRES\_USER = postgres the \sphinxhyphen{}eflag menyetel variabel lingkungan di dalam penampung. Yang ini digunakan untuk mengonfigurasi nama peran login di PostgreSQL yang akan memiliki hak superuser (admin) di database. Anda dapat mengubah nama ini menjadi apa pun yang Anda inginkan.

\item {} 
\sphinxhyphen{}e POSTGRES\_PASS = postgres menyetel variabel lingkungan yang akan menyetel kata sandi peran login menjadi `kata sandi. Anda dapat mengatur ini menjadi apa pun yang Anda inginkan.

\item {} 
\sphinxhyphen{}e POSTGRES\_DBNAME = gis seperti yang bisa Anda tebak, variabel lingkungan memberi tahu container untuk membuat database baru di server dengan nama gis. Setelah database dibuat maka extension PostGIS akan diaktifkan di dalamnya.

\item {} 
\sphinxhyphen{}e ALLOW\_IP\_RANGE = 0.0.0.0 / 0 memberi tahu container untuk mengkonfigurasi PostgreSQL untuk menerima koneksi dari siapa pun. Jika Anda tidak mengatur ini maka database hanya akan menerima koneksi dari alamat menggunakan subnet jaringan Docker.

\item {} 
\sphinxhyphen{}p 5432: 5432 memetakan port 5432 pada VM host ke port 5432 pada container. Ini diperlukan karena server database mendengarkan koneksi pada port 5432 secara default.

\item {} 
\sphinxhyphen{}v pg\_data: / var / lib / postgresql memberi tahu sistem file container untuk memasang volume pg\_data yang baru saja kita buat ke jalur / var / lib / postgresql. Ini berarti bahwa data apa pun yang disimpan atau dibuat container di direktori itu akan disimpan dalam volume pg\_data.

\item {} 
–restart = selalu membuat kebijakan restart untuk penampung Anda. Sekarang penampung Anda akan mulai setiap kali mesin virtual Docker dimulai. Jika ini tidak disetel, Anda harus memulai penampung secara manual setiap kali VM di\sphinxhyphen{}boot dengan docker start postgis

\item {} 
kartoza / postgis: 13.0 memberitahu Docker untuk menarik repositori kartoza / postgis dari Docker Hub, menggunakan PostgreSQL versi 9.6 dan PostGIS versi 2.4. Anda dapat melihat versi lain yang tersedia di \sphinxhref{https://hub.docker.com/r/kartoza/postgis/tags/?page=1\&ordering=last\_updated}{sini}

\end{itemize}

\item {} 
Tunggu sampai instalasi selesai. Periksa apakah mesin yang digunakan sudah menyala menggunakan perintah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker ps
\end{sphinxVerbatim}

\end{enumerate}

Selanjutnya, PostGIS dan PostgreSQL siap untuk digunakan.

\sphinxincludegraphics{{2020-12-03-08-54-59}.png}

 


\subsection{Menggunakan Query SQL pada Basisdata}
\label{\detokenize{sesi2/relationaldb:menggunakan-query-sql-pada-basisdata}}
Untuk mengirimkan SQL pada Basisdata PostgreSQL dapat digunakan beberapa aplikasi antarmuka yang berbeda. \sphinxcode{\sphinxupquote{psql}} dan \sphinxcode{\sphinxupquote{pgAdmin}} barangkali merupakan antarmuka untuk basisdata PostgreSQL yang paling terkenal. Sejatinya, koneksi pada basisdata dapat dilakukan pada berbagai aplikasi, dengan syarat terdapat port dan host yang terbuka untuk melakukan koneksi pada PostgreSQL seperti yang akan kita lakukan nanti dengan QGIS. Untuk memulai, terlebih dahulu akan kita gunakan kedua aplikasi yang telah disebutkan di atas.


\subsubsection{Latihan: Menggunakan \sphinxstyleliteralintitle{\sphinxupquote{psql}} untuk melakukan query sederhana}
\label{\detokenize{sesi2/relationaldb:latihan-menggunakan-psql-untuk-melakukan-query-sederhana}}
\sphinxcode{\sphinxupquote{psql}} merupakan aplikasi untuk manajemen client postgreSQL. Dengan aplikasi ini, script SQL dapat dibuat melalui \sphinxstyleemphasis{command prompt}. Contohnya, koneksi pada basisdata dapat dilakukan sebagai berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
psql \PYGZhy{}d database \PYGZhy{}h host \PYGZhy{}U  user \PYGZhy{}W
\end{sphinxVerbatim}

Aplikasi ini tersedia bersama dengan instalasi PostgreSQL dan PostGIS yang sudah kita install menggunakan \sphinxstylestrong{Docker Kartoza}. Dalam hal ini, aplikasi ini sekarang tersimpan di dalam mesin Docker, dan bukan pada WSL, sehingga kita perlu melakukan \sphinxhref{https://github.com/gis-ops/tutorials/blob/postgrest-elevation-api/postgres/postgres\_postgis\_postgrest\_installation.md}{langkah tambahan} untuk melakukan akses tersebut:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Masuk ke dalam Docker menggunakan perintah \sphinxcode{\sphinxupquote{docker exec}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker \PYG{n+nb}{exec} \PYGZhy{}it postgis bash
\end{sphinxVerbatim}

\item {} 
Install text editor, misalnya \sphinxstylestrong{nano}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
apt\PYGZhy{}get update \PYG{o}{\PYGZam{}\PYGZam{}} apt\PYGZhy{}get install nano
\end{sphinxVerbatim}

\item {} 
Masuk ke folder instalasi PostgreSQL

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} /etc/postgresql/13/main/
\end{sphinxVerbatim}

\item {} 
Dengan menggunakan \sphinxstylestrong{nano}, lakukan editing pada file \sphinxcode{\sphinxupquote{pg\_hba.conf}}. Ubah \sphinxcode{\sphinxupquote{peer}} menjadi \sphinxcode{\sphinxupquote{trust}} pada \sphinxstylestrong{Database administrative login by Unix domain socket} seperti berikut:
\sphinxincludegraphics{{2020-12-03-12-40-15}.png}

\item {} 
Keluar dari mesin dan lakukan restart untuk kontainer PostGIS

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker restart postgis
\end{sphinxVerbatim}

\item {} 
Gunakan \sphinxcode{\sphinxupquote{psql}} seperti berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker \PYG{n+nb}{exec} \PYGZhy{}it postgis psql \PYGZhy{}U postgres
\end{sphinxVerbatim}

maka kita akan masuk ke shell untuk \sphinxcode{\sphinxupquote{psql}}:
\sphinxincludegraphics{{2020-12-03-12-43-10}.png}

\item {} 
Pada shell ini kita dapat langsung mengetikkan Query yang kita inginkan, misalnya:
\sphinxcode{\sphinxupquote{postgres=\# SELECT * FROM anggota;}}

\item {} 
Selain melalui konsol, kita juga dapat membuat query menggunakan \sphinxstyleemphasis{command}, seperti berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{exec} \PYG{o}{\PYGZhy{}}\PYG{n}{it} \PYG{n}{postgis} \PYG{n}{psql} \PYG{o}{\PYGZhy{}}\PYG{n}{U} \PYG{n}{postgres} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{latihan} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SELECT * FROM anggota}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{enumerate}

\begin{sphinxadmonition}{note}{Catatan}

Tentunya untuk kedua contoh SELECT di atas, basisdata \sphinxcode{\sphinxupquote{latihan}} dan tabel \sphinxcode{\sphinxupquote{anggota}} harus sudah tersedia terlebih dahulu.
\end{sphinxadmonition}

Untuk latihan ini, coba gunakan query pada tabel \sphinxcode{\sphinxupquote{anggota}} seperti di atas menggunakan \sphinxcode{\sphinxupquote{psql}}, yaitu dari pembuatan tabel hingga mengajukan pertanyaan. Buat basisdata baru dengan nama \sphinxcode{\sphinxupquote{Latihan}}, kemudian masukkan tabel \sphinxcode{\sphinxupquote{anggota}}. Gunakan perintah\sphinxhyphen{}perintah DDL dan DML untuk membuat dan mengoperasikan basisdata ini melalui \sphinxcode{\sphinxupquote{psql}}.

Daftar \sphinxhref{https://gist.github.com/Kartones/dd3ff5ec5ea238d4c546}{perintah} untuk \sphinxcode{\sphinxupquote{psql}} dapat dilihat pada:
https://www.postgresqltutorial.com/postgresql\sphinxhyphen{}cheat\sphinxhyphen{}sheet/.


\subsubsection{Latihan: Menggunakan pgAdmin sebagai GUI Basisdata PostgreSQL}
\label{\detokenize{sesi2/relationaldb:latihan-menggunakan-pgadmin-sebagai-gui-basisdata-postgresql}}
Pada bagian ini, \sphinxstylestrong{pgAdmin4} akan digunakan sebagai antarmuka untuk PostgreSQL. pgAdmin merupakan antarmuka PostgreSQL yang menyediakan GUI (\sphinxstyleemphasis{Graphical User Interface}) sehingga memudahkan untuk mengajukan Query, memanajemen basisdata, memonitor transaksi, dan seterusnya.

Terlebih dahulu unduh pgAdmin4 dari alamat berikut:
https://www.pgadmin.org/download/

 Selanjutnya, lakukan instalasi pada sistem operasi Windows. Tampilan \sphinxstylestrong{pgAdmin4} setelah instalasi adalah sebagai berikut:
 \sphinxincludegraphics{{2020-12-03-08-55-40}.png}

 Koneksi dapat dilakukan pada basisdata melalui pgAdmin4 sebagai berikut. Klik kanan pada \sphinxcode{\sphinxupquote{Server}}, kemudian pilih \sphinxcode{\sphinxupquote{Create Server}}.

\sphinxincludegraphics{{2020-12-08-08-01-41}.png}

Masukkan nama dan parameter koneksi seperti contoh berikut:

 \sphinxincludegraphics{{2020-12-03-08-57-17}.png}

 dimana \sphinxstyleemphasis{alamat host} adalah ip address yang digunakan oleh mesin Docker.
 

 untuk mendapatkan alamat tersebut, gunakan perintah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ip addr
\end{sphinxVerbatim}

kemudian lihat ip address untuk \sphinxcode{\sphinxupquote{eth0}}. Alamat ini adalah alamat IP yang digunakan oleh Windows untuk berkomunikasi dengan WSL, sehingga kita dapat menggunakannya untuk terhubung dengan PostgreSQL. Pada kasus instalasi PostgreSQL langsung di mesin server, alamat yang dicari ini dapat dibuat cukup dengan menggunakan \sphinxcode{\sphinxupquote{localhost}} saja. Diagram berikut menggambarkan bagaimana Windows terhubung pada WSL dengan menggunakan koneksi melalui IP Address yang dimaksud.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-03-09-00-55}.png}
\caption{Koneksi pada WSL}\label{\detokenize{sesi2/relationaldb:table2}}\end{figure}

Setelah terhubung, PostgreSQL akan menampilkan beberapa menu yang dapat digunakan untuk melakukan manajemen basisdata. Untuk melakukan Query pada basisdata tertentu, klik pada basisdata tersebut, kemudian gunakan menu \sphinxcode{\sphinxupquote{Query Tool}} untuk membuat query terhadap basisdata ini.

\sphinxincludegraphics{{2020-12-08-08-04-07}.png}

Perintah SQL seperti yang kita sebutkan di atas dapat digunakan pada jendela Query yang tersedia.

\sphinxincludegraphics{{2020-12-08-08-05-07}.png}

\begin{sphinxadmonition}{note}{Catatan}

Mesin Docker PostGIS yang kita panggil pada WSL akan tetap berjalan sampai kita matikan. Untuk memeriksa mesin apa saja yang sedang berjalan, kita dapat gunakan:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker ps
\end{sphinxVerbatim}
\end{sphinxadmonition}

Maka Docker akan menampilkan daftar mesin yang sedang berjalan. Untuk menghentikan semua mesin, kita gunakan perintah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker stop \PYG{k}{\PYGZdl{}(}docker ps \PYGZhy{}aq\PYG{k}{)}
\end{sphinxVerbatim}

dan untuk memulai kembali mesin tersebut, cukup panggil dengan menggunakan:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker start postgis
\end{sphinxVerbatim}

dimana \sphinxcode{\sphinxupquote{postgis}} adalah nama mesin yang kita definisikan menggunakan parameter \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}name}} pada saat memanggil image ini. Dalam hal ini Docker tidak akan mengunduh instalasi baru karena berkas tersebut masih ada pada WSL.

\begin{sphinxVerbatim}[commandchars=\\\{\}]














\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\section{Administrasi Pengguna pada Basisdata}
\label{\detokenize{sesi2/dbmanagement:administrasi-pengguna-pada-basisdata}}\label{\detokenize{sesi2/dbmanagement::doc}}
Pada basisdata enterprise, concurrent use atau pemakaian bersama menjadi kebutuhan utama pada sistem yang berjalan. Sama seperti pada sistem operasi Linux yang sudah dibahas sebelumnya, terdapat pengaturan untuk memberikan izin pada basisdata yang memungkinkan pengguna berbeda mempunyai izin akses yang berbeda.


\subsection{Roles, Group dan Priviledges}
\label{\detokenize{sesi2/dbmanagement:roles-group-dan-priviledges}}
Izin pada pengguna di PostgreSQL mirip dengan pemberian izin pada Linux: pembagian peran (role) dapat diberikan pada user maupun grup, dengan tiap role memiliki hak akses (priviledges) yang berbeda

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=400\sphinxpxdimen]{{2020-12-03-09-08-19}.png}
\caption{Roles pada PostgreSQL dapat diberikan pada \sphinxcode{\sphinxupquote{grup}} maupun pada \sphinxcode{\sphinxupquote{user}}}\label{\detokenize{sesi2/dbmanagement:pgroles}}\end{figure}

Berikut adalah beberapa peran yang dapat diberikan pada pengguna atau grup:
\begin{itemize}
\item {} 
\sphinxstylestrong{SUPERUSER} \sphinxhyphen{} SUPERUSER database perlu mendapat perhatian khusus. Intinya, peran dengan atribut ini dapat membuat SUPERUSER lain. Faktanya, atribut ini diperlukan untuk membuat peran SUPERUSER lainnya. Karena peran dengan atribut ini mengabaikan semua pemeriksaan izin, berikan hak istimewa ini dengan bijaksana.

\item {} 
\sphinxstylestrong{CREATEDB} \sphinxhyphen{} Memungkinkan peran untuk membuat database.

\item {} 
\sphinxstylestrong{CREATEROLE} \sphinxhyphen{} Dengan atribut ini, peran dapat mengeluarkan perintah CREATE ROLE, yaitu membuat peran lain.

\item {} 
\sphinxstylestrong{LOGIN} \sphinxhyphen{} Memungkinkan kemampuan untuk login. Nama peran dengan atribut ini dapat digunakan dalam perintah koneksi klien.

\end{itemize}

Pada PostgreSQL, pengaturan ini dapat dijumpai pada menu Create Roles, seperti berikut:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=400\sphinxpxdimen]{{2020-12-08-08-09-45}.png}
\caption{Menu pengaturan Roles pada PostgreSQL}\label{\detokenize{sesi2/dbmanagement:pengaturanroles}}\end{figure}


\subsection{Pengaturan hak akses pada PostgreSQL}
\label{\detokenize{sesi2/dbmanagement:pengaturan-hak-akses-pada-postgresql}}
Dengan PostgreSQL, Anda dapat membuat pengguna dan peran dengan izin akses secara \sphinxstyleemphasis{granular}. Pengguna atau peran baru harus secara selektif diberikan izin yang diperlukan untuk setiap objek database. Ini memberi banyak kekuatan kepada pengguna akhir, tetapi pada saat yang sama, itu membuat proses pembuatan pengguna dan peran dengan izin yang benar berpotensi rumit.

PostgreSQL memungkinkan Anda memberikan izin langsung ke pengguna database. Namun, sebagai praktik yang baik, Anda disarankan untuk membuat \sphinxstylestrong{banyak peran} dengan kumpulan izin tertentu berdasarkan aplikasi dan persyaratan akses. Kemudian tetapkan peran yang sesuai untuk setiap pengguna. Peran harus digunakan untuk menerapkan model dengan hak istimewa terendah untuk mengakses objek database. Pengguna master pada PostgreSQL harus digunakan hanya untuk tugas administrasi database seperti membuat pengguna, peran, dan database lain. Pengguna master tidak boleh digunakan oleh aplikasi. Berikut adalah contoh pembagian peran dan pemberian izin:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=400\sphinxpxdimen]{{2020-12-03-09-09-34}.png}
\caption{Contoh pengaturan untuk pembagian peran pada PostgreSQL}\label{\detokenize{sesi2/dbmanagement:pembagianperan}}\end{figure}


\subsubsection{Membuat pengguna dan grup baru}
\label{\detokenize{sesi2/dbmanagement:membuat-pengguna-dan-grup-baru}}
Pengguna pada PostgreSQL dibuat melalui query berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{k}{CREATE} \PYG{k}{USER} \PYG{n}{username} \PYG{p}{[} \PYG{p}{[} \PYG{k}{WITH} \PYG{p}{]} 
   \PYG{k}{SYSID} \PYG{n}{uid} 
   \PYG{o}{|} \PYG{p}{[} \PYG{k}{ENCRYPTED} \PYG{o}{|} \PYG{k}{UNENCRYPTED} \PYG{p}{]} \PYG{n}{PASSWORD} \PYG{l+s+s1}{\PYGZsq{}password\PYGZsq{}}
   \PYG{o}{|} \PYG{k}{CREATEDB} \PYG{o}{|} \PYG{k}{NOCREATEDB}
   \PYG{o}{|} \PYG{k}{CREATEUSER} \PYG{o}{|} \PYG{k}{NOCREATEUSER}
   \PYG{o}{|} \PYG{k}{IN} \PYG{k}{GROUP} \PYG{n}{groupname} \PYG{p}{[}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}
   \PYG{o}{|} \PYG{k}{VALID} \PYG{k}{UNTIL} \PYG{l+s+s1}{\PYGZsq{}abstime\PYGZsq{}} \PYG{p}{]}
\end{sphinxVerbatim}

Sebagai contoh, perintah berikut akan membuat \sphinxstylestrong{pengguna baru} dengan nama ‘user1’ dan password ‘password1’:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{USER} \PYG{n}{user1} \PYG{k}{WITH} \PYG{n}{PASSWORD} \PYG{l+s+s1}{\PYGZsq{}password1\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

Adapun \sphinxstylestrong{grup} merupakan salah satu cara untuk mengelompokkan pengguna tertentu. Grup dapat dibuat dengan perintah berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{GROUP} \PYG{n}{sales} \PYG{k}{WITH} \PYG{k}{USER} \PYG{n}{user1}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Menerapkan peran baru}
\label{\detokenize{sesi2/dbmanagement:menerapkan-peran-baru}}
\sphinxstylestrong{\sphinxhref{https://www.postgresql.org/docs/13/user-manag.html}{Role}} merupakan cara PostgreSQL mengatur batasan akses oleh pengguna. Tiap Role dapat memiliki pengaturan \sphinxstyleemphasis{Priviledges} yang berbeda untuk membatasi hak akses yang dapat dilakukan oleh tiap\sphinxhyphen{}tiap pengguna. Berikut adalah bagaimana peran dibuat dengan menggunakan bahasa SQL:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{ROLE} \PYG{n}{user\PYGZus{}viewer} \PYG{k}{WITH} \PYG{n}{LOGIN} \PYG{n}{PASSWORD} \PYG{l+s+s1}{\PYGZsq{}pass2\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

PostgreSQL 13 telah dilengkapi dengan beberapa roles default yang dapat digunakan, yaitu sebagai berikut:

\sphinxincludegraphics{{2020-12-08-08-16-03}.png}

Peran \sphinxstyleemphasis{default} tersebut dapat diberikan pada pengguna tertentu melalui perintah:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{GRANT} \PYG{n}{pg\PYGZus{}read\PYGZus{}server\PYGZus{}files} \PYG{k}{TO} \PYG{n}{user1}\PYG{p}{;}
\end{sphinxVerbatim}

Demikian pula, perintah tersebut dapat dilakukan untuk grup, sehingga hak akses menjadi milik semua pengguna pada grup tersebut.


\subsubsection{Latihan: Menggunakan Pengaturan Roles untuk membatasi akses}
\label{\detokenize{sesi2/dbmanagement:latihan-menggunakan-pengaturan-roles-untuk-membatasi-akses}}
Untuk latihan ini, kita akan gunakan tabel \sphinxcode{\sphinxupquote{anggota}} pada latihan sebelumnya. Kita akan membuat skema pengaturan pengguna melalui grup, user dan roles untuk membatasi akses pada tabel \sphinxcode{\sphinxupquote{anggota}}. Kita akan menggunakan Query pada PostgreSQL untuk keperluan ini (bukan antarmuka PostgreSQL \sphinxhyphen{} menggunakan Query relatif lebih sederhana).

\sphinxincludegraphics{{2020-12-08-08-30-36}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Langkah pertama adalah membuat \sphinxstyleemphasis{role} baru untuk pengguna kita nantinya. Role ini diatur agar hanya dapat membaca tabel tertentu:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{ROLE} \PYG{n}{readonly\PYGZus{}tabel}\PYG{p}{;}
\PYG{k}{GRANT} \PYG{k}{CONNECT} \PYG{k}{ON} \PYG{k}{DATABASE} \PYG{n}{latihan} \PYG{k}{TO} \PYG{n}{readonly\PYGZus{}tabel}\PYG{p}{;}
\PYG{k}{GRANT} \PYG{k}{USAGE} \PYG{k}{ON} \PYG{k}{SCHEMA} \PYG{k}{public} \PYG{k}{TO} \PYG{n}{readonly\PYGZus{}tabel}\PYG{p}{;}
\end{sphinxVerbatim}

Tiga perintah di atas berfungsi untuk membuat role baru, memberikan hak akses atas basisdata \sphinxcode{\sphinxupquote{latihan}} kepada role tersebut, serta memberi akses pada skema \sphinxcode{\sphinxupquote{public}} yang terdapat di dalam basisdata latihan. Hasilnya adalah sebagai berikut:

\sphinxincludegraphics{{2020-12-08-08-28-48}.png}

\item {} 
Kita akan membatasi akses ke tabel \sphinxcode{\sphinxupquote{anggota}} agar role \sphinxcode{\sphinxupquote{readonly\_tabel}} hanya dapat membaca kolom id dan jenis kelamin saja.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{GRANT} \PYG{k}{SELECT} \PYG{p}{(}\PYG{n}{no\PYGZus{}id}\PYG{p}{,} \PYG{n}{jenis\PYGZus{}kelamin}\PYG{p}{)} \PYG{k}{ON} \PYG{k}{TABLE} \PYG{k}{public}\PYG{p}{.}\PYG{n}{anggota} \PYG{k}{TO} \PYG{n}{readonly\PYGZus{}tabel}\PYG{p}{;}
\end{sphinxVerbatim}

pada perintah di atas, user budi hanya dapat mengakses kolom no\_id dan jenis\_kelamin

\item {} 
Membuat pengguna baru untuk akses dengan role ini

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{USER} \PYG{n}{budi} \PYG{k}{WITH} \PYG{n}{PASSWORD} \PYG{l+s+s1}{\PYGZsq{}secret\PYGZsq{}}\PYG{p}{;}
\PYG{k}{GRANT} \PYG{n}{readonly\PYGZus{}tabel} \PYG{k}{TO} \PYG{n}{budi}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Lakukan koneksi ke PostgreSQL dengan user baru ini. Gunakan antarmuka PostgreSQL untuk Logout, kemudian login kembali dengan user \sphinxcode{\sphinxupquote{budi}} dan password \sphinxcode{\sphinxupquote{secret}}.

\item {} 
Buat query untuk memilih seluruh isi tabel anggota:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{k}{TABLE} \PYG{n}{anggota}
\end{sphinxVerbatim}

hasilnya adalah error karena user \sphinxcode{\sphinxupquote{budi}} tidak diizinkan untuk mengakses seluruh isi tabel:

\sphinxincludegraphics{{2020-12-08-08-49-47}.png}

\item {} 
Apabila kita hanya memilih kolom \sphinxcode{\sphinxupquote{no\_id}} dan \sphinxcode{\sphinxupquote{jenis\_kelamin}}, maka hasilnya:

\sphinxincludegraphics{{2020-12-08-08-54-57}.png}

\end{enumerate}

Latihan di atas menunjukkan bagaimana pengaturan role pada pengguna dapat digunakan untuk membatasi akses pada basisdata, tabel, kolom maupun view. Dengan demikian kita dapat mengatur hak akses yang cukup kompleks untuk berbagai kebutuhan.


\subsection{Mengatur koneksi multi\sphinxhyphen{}pengguna}
\label{\detokenize{sesi2/dbmanagement:mengatur-koneksi-multi-pengguna}}
Apabila terdapat beberapa pengguna, maka hak akses (priviledges) untuk tiap pengguna ini dapat ditentukan dengan mengaturnya melalui roles, group maupun langsung ke pengguna itu sendiri.


\subsubsection{Latihan: Pengaturan Priviledges}
\label{\detokenize{sesi2/dbmanagement:latihan-pengaturan-priviledges}}
PostgreSQL memiliki dua tingkat otorisasi, satu di tingkat database, yang disebut \sphinxhref{https://www.davidpashley.com/articles/postgresql-user-administration/}{otentikasi berbasis \sphinxstylestrong{host}}, dan satu lagi di tingkat yang lebih detil pada tabel, \sphinxstyleemphasis{view}, dan \sphinxstyleemphasis{sequence}.
Adapun daftar permission yang dapat diberikan pada pengguna adalah:

\sphinxincludegraphics{{2020-12-03-10-49-58}.png}

Berikut adalah contoh pemberian izin kepada pengguna untuk mengakses basisdata tertentu:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
GRANT \PYGZob{} \PYGZob{} SELECT | INSERT | UPDATE | DELETE | RULE | REFERENCES | TRIGGER \PYGZcb{}
    [,...] | ALL [ PRIVILEGES ] \PYGZcb{}
    ON [ TABLE ] tablename [, ...]
    TO \PYGZob{} username | GROUP groupname | PUBLIC \PYGZcb{} [, ...] [ WITH GRANT OPTION ]
\end{sphinxVerbatim}

Seagai contoh, untuk memberikan izin pada ‘\sphinxstylestrong{bob}’ untuk memodifikasi tabel \sphinxstylestrong{supplier}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{GRANT} \PYG{k}{INSERT}\PYG{p}{,} \PYG{k}{UPDATE}\PYG{p}{,} \PYG{k}{DELETE} \PYG{k}{ON} \PYG{k}{TABLE} \PYG{n}{suppliers} \PYG{k}{TO} \PYG{n}{bob}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Latihan: Terhubung dengan server basisdata}
\label{\detokenize{sesi2/dbmanagement:latihan-terhubung-dengan-server-basisdata}}
Sebagai latihan, gunakan koneksi berikut untuk terhubung pada basisdata PostGIS yang tersimpan di Amazon Lightsail:

host: 54.254.9.31
port: 5432

user 1:
\begin{itemize}
\item {} 
username: view\_only

\item {} 
password: ‘viewer’

\item {} 
role: pg\_read\_server\_file

\end{itemize}

user 2:
\begin{itemize}
\item {} 
username: editor\_data

\item {} 
password: ‘editor’

\item {} 
role: pg\_write\_server\_file

\end{itemize}

user 3 (SUPERUSER):
\begin{itemize}
\item {} 
username: postgres

\item {} 
password: ‘postgres’

\end{itemize}


\section{Basisdata Spasial dengan PostGIS}
\label{\detokenize{sesi2/postgisquery:basisdata-spasial-dengan-postgis}}\label{\detokenize{sesi2/postgisquery::doc}}
Pada bagian ini akan dibahas mengenai bagaimana menggunakan PostGIS untuk melakukan analisis spasial sederhana. QGIS akan digunakan sebagai antarmuka utama untuk melakukan koneksi pada PostGIS dan menampilkan hasil analisis.

\begin{sphinxadmonition}{note}{Catatan}

Latihan ini akan menggunakan QGIS, sehingga terlebih dahulu lakukan instalasi QGIS.

Adapun Data untuk latihan ini dapat diperoleh dari link berikut:

\sphinxurl{https://github.com/danylaksono/sleman-dataset/}

Gunakan Github untuk melakukan clone atau unduh seluruh data sebagai zip
\end{sphinxadmonition}


\subsection{Pengantar PostGIS}
\label{\detokenize{sesi2/postgisquery:pengantar-postgis}}
Dalam implementasi GIS \sphinxstylestrong{generasi pertama}, semua data spasial disimpan dalam file datar dan perangkat lunak GIS khusus diperlukan untuk menafsirkan dan memanipulasi data. Sistem pengelolaan generasi pertama ini dirancang untuk memenuhi kebutuhan pengguna yang semua data yang diperlukan berada dalam domain organisasi pengguna. Mereka adalah sistem berpemilik dan mandiri yang secara khusus dibangun untuk menangani data spasial.

Sistem spasial \sphinxstylestrong{generasi kedua} menyimpan beberapa data dalam database relasional (biasanya “atribut” atau bagian non\sphinxhyphen{}spasial) tetapi masih kekurangan fleksibilitas yang diberikan dengan integrasi langsung.
\begin{quote}

\sphinxstyleemphasis{“Database spasial sejati lahir ketika orang mulai memperlakukan fitur spasial sebagai objek database kelas satu.”}
\end{quote}

Database spasial sepenuhnya mengintegrasikan data spasial dengan database relasional objek. Orientasi berubah dari \sphinxstyleemphasis{GIS\sphinxhyphen{}centric} menjadi \sphinxstyleemphasis{database\sphinxhyphen{}centric}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=400\sphinxpxdimen]{{2020-12-03-07-15-37}.png}
\caption{Evolusi Basisdata Spasial untuk GIS}\label{\detokenize{sesi2/postgisquery:evolusi}}\end{figure}

Untuk memanipulasi data selama kueri, database biasa menyediakan fungsi seperti menggabungkan string, melakukan operasi hash pada string, melakukan matematika pada angka, dan mengekstraksi informasi dari tanggal. Database spasial menyediakan satu set lengkap fungsi untuk menganalisis komponen geometris, menentukan hubungan spasial, dan memanipulasi geometri. Fungsi spasial ini berfungsi sebagai blok bangunan untuk setiap proyek tata ruang.

Mayoritas dari semua fungsi spasial pada PostGIS dapat dikelompokkan ke dalam salah satu dari lima kategori berikut:
\begin{itemize}
\item {} 
\sphinxstylestrong{Konversi}: Fungsi yang mengonversi antara geometri dan format data eksternal.

\item {} 
\sphinxstylestrong{Manajemen}: Fungsi yang mengatur informasi tentang tabel spasial dan administrasi PostGIS.

\item {} 
\sphinxstylestrong{Retrieval}: F  ungsi yang mengambil properti dan pengukuran Geometri.

\item {} 
\sphinxstylestrong{Perbandingan}: Fungsi yang membandingkan dua geometri sehubungan dengan hubungan spasialnya.

\item {} 
\sphinxstylestrong{Pembuatan data}: Fungsi yang menghasilkan geometri baru dari orang lain.
Daftar fungsi yang mungkin sangat besar, tetapi sekumpulan fungsi umum ditentukan oleh OGC SFSQL dan diimplementasikan (bersama dengan fungsi tambahan yang berguna) oleh PostGIS.

\end{itemize}


\subsection{Menggunakan QGIS sebagai antarmuka PostGIS}
\label{\detokenize{sesi2/postgisquery:menggunakan-qgis-sebagai-antarmuka-postgis}}
QGIS barangkali merupakan perangkat lunak GIS OpenSource yang paling terkenal. QGIS memiliki berbagai dukungan format data spasial, termasuk untuk koneksi terhadap basisdata PostGIS. Pada latihan ini akan digunakan QGIS untuk melakukan koneksi pada basisdata.

QGIS memiliki berbagai opsi untuk terhubung dengan beragam format data yang berbeda. Koneksi ke basisdata PostgreSQL (dan dengan demikian PostGIS), dapat dilakukan melalui menu Data Source Manager sebagai berikut:

\sphinxincludegraphics{{2020-12-08-10-11-09}.png}

Lakukan koneksi pada basisdata PostGIS yang tersimpan pada WSL. Gunakan menu connect untuk menyambungkan basisdata sesuai dengan parameter yang diperlukan. Untuk saat ini, basisdata ini masih kosong tanpa ada isi apapun. Kita akan gunakan data dari unduhan di atas untuk mengisi basisdata ini dengan menggunakan QGIS.


\subsubsection{Latihan: Memasukkan Data pada PostGIS}
\label{\detokenize{sesi2/postgisquery:latihan-memasukkan-data-pada-postgis}}
Berikut adalah data yang tersedia pada link unduhan yang disebutkan di atas:
Data vector yang digunakan berupa data di daerah Kabupaten Sleman, antara lain:
*	Data jaringan jalan (line)
*	Data jaringan sungai (line)
*	Data bangunan (polygon)
*	Data titik\sphinxhyphen{}titik penting (point)
*	Data batas administrasi (polygon)
*	Data penggunaan lahan (multipolygon)
*	Data Kawasan Rawan Bencana (KRB) BNPB 2010 (polygon)
Data berupa raster terdiri atas:
*	Raster populasi penduduk Indonesia dengan resolusi 100 meter yang diambil dari www.worldpop.org.uk
*	Raster SRTM dengan resolusi 30 meter.

Untuk latihan ini, terlebih dahulu kita masukkan data\sphinxhyphen{}data tersebut di atas ke dalam Basisdata PostGIS. Kita akan menggunakan basisdata \sphinxcode{\sphinxupquote{latihan}} yang kita buat pada latihan sebelumnya. Akan tetapi, kita perlu untuk terlebih dulu mengaktifkan ekstensi PostGIS pada basisdata \sphinxcode{\sphinxupquote{latihan}}. Gunakan \sphinxcode{\sphinxupquote{psql}} atau \sphinxcode{\sphinxupquote{pgAdmin4}} untuk menjalankan query berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{n}{EXTENSION} \PYG{n}{postgis}\PYG{p}{;}
\end{sphinxVerbatim}

Kita dapat memeriksa bahwa ekstensi postgis telah diaktifkan pada basisdata ini menggunakan pgAdmin:

\sphinxincludegraphics{{2020-12-08-11-09-21}.png}

Dengan demikian, basisdata \sphinxcode{\sphinxupquote{latihan}} sudah dapat digunakan untuk menyimpan dan menganalisis data geospasial. Untuk itu kita akan masukkan data vektor dan data raster di atas ke dalam basisdata. QGIS memiliki menu yang praktis untuk keperluan ini.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Untuk data vektor, kita akan gunakan QGIS untuk memasukkan data pada PostGIS. Pastikan bahwa basisdata telah terkoneksi melalui menu \sphinxcode{\sphinxupquote{Data Source Manager}} pada langkah sebelumnya.

\sphinxincludegraphics{{2020-12-08-11-14-45}.png}

Centang \sphinxcode{\sphinxupquote{also list tables with no geometry}} akan memunculkan tabel \sphinxcode{\sphinxupquote{anggota}} yang kita gunakan pada latihan sebelumnya.    Parameter koneksi pada antarmuka tersebut sama dengan parameter koneksi yang diperlukan untuk menghubungkan pgAdmin dan PostgreSQL pada latihan sebelumnya.

\item {} 
Selanjutnya, tambahkan tiap layer \sphinxstylestrong{shapefile} pada data unduhan ke dalam QGIS, seperti berikut:

\sphinxincludegraphics{{2020-12-08-13-01-57}.png}

\item {} 
Buka menu \sphinxstylestrong{DBManager}, kemudian lakukan koneksi ke basisdata (cukup dengan membuka/expand koneksi basisdata yang dimaksud)

\sphinxincludegraphics{{2020-12-08-13-05-18}.png}

\item {} 
Gunakan menu \sphinxcode{\sphinxupquote{Import Layer/File...}} untuk mengkonversi layer pada QGIS menjadi tabel pada PostGIS, seperti berikut.

\sphinxincludegraphics{{2020-12-08-13-07-12}.png}

Penggunaan Spatial Index akan sangat membantu apabila data yang digunakan cukup besar.

\begin{sphinxadmonition}{note}{Catatan}

Karena suatu alasan, QGIS sepertinya tidak mendukung penggunaan huruf besar pada nama tabel maupun kolom. Gunakan huruf kecil pada nama \sphinxstylestrong{Table} dan centang \sphinxcode{\sphinxupquote{Convert field names to lowercase}} untuk memastikan tidak ada masalah pada saat menjalankan SQL nantinya.
\end{sphinxadmonition}

\item {} 
Gunakan menu SQL Window untuk memasukkan Query:

\sphinxincludegraphics{{2020-12-08-13-14-28}.png}

\item {} 
Hasil Query dapat disimpan dalam bentuk View (tabel baru) maupun layer pada QGIS. Klik pada centang \sphinxcode{\sphinxupquote{Load as New Layer}}
\sphinxincludegraphics{{2020-12-08-13-15-59}.png}

Klik Load untuk memuat layer tersebut pada QGIS

\end{enumerate}

Pada pembahasan di bawah ini terdapat contoh\sphinxhyphen{}contoh penggunaan SQL pada PostGIS untuk menyelesaikan berbagai permasalahan. Sebelum itu, kita perlu memasukkan terlebih dahulu data raster ke dalam basisdata PostGIS. Untuk menambahkan raster ke PostGIS kita dapat menggunakan fungsi \sphinxcode{\sphinxupquote{raster2pgsql}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Untuk data raster, terlebih dahulu kita perlu mengakses mesin Docker dengan mengcopikan data pada root mesin tersebut, sebagai berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker \PYG{n+nb}{exec} \PYGZhy{}it postgis bash \PYGZhy{}c \PYG{l+s+s2}{\PYGZdq{}apt\PYGZhy{}get update \PYGZam{}\PYGZam{} apt\PYGZhy{}get install postgis\PYGZdq{}}
docker cp dem.tif postgis:/
\end{sphinxVerbatim}

ini apabila kita asumsikan data raster yang kita copykan bernama \sphinxcode{\sphinxupquote{dem.tif}}.

\item {} 
Selanjutnya, gunakan raster2pgsql untuk mengkonversi raster menjadi sql melalui operasi \sphinxstyleemphasis{pipe}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker \PYG{n+nb}{exec} \PYGZhy{}it postgis bash \PYGZhy{}c \PYG{l+s+s1}{\PYGZsq{}raster2pgsql \PYGZhy{}s 32749 \PYGZhy{}I \PYGZhy{}C \PYGZhy{}M dem.tif \PYGZhy{}F \PYGZhy{}t 100x100 public.rstdem  | psql \PYGZhy{}U postgres \PYGZhy{}d latihan\PYGZsq{}}
\end{sphinxVerbatim}

Dengan demikian, \sphinxcode{\sphinxupquote{raster2pgsql}} akan mengkonversi data \sphinxcode{\sphinxupquote{dem.tif}} menjadi tabel \sphinxcode{\sphinxupquote{rstdem}} pada basisdata \sphinxcode{\sphinxupquote{latihan}}.

\end{enumerate}

Setelah semua data selesai kita muat pada QGIS, saatnya meng\sphinxhyphen{}eksplorasi berbagai fungsi analisis PostGIS. Berikut adalah beberapa contoh penggunaan fungsi pada PostGIS untuk keperluan analisis spasial pada data vektor maupun raster.

 


\subsubsection{Latihan: Query Spasial pada data vektor}
\label{\detokenize{sesi2/postgisquery:latihan-query-spasial-pada-data-vektor}}
Berikut adalah beberapa latihan yang dapat dilakukan menggunakan QGIS dan PostGIS. Gunakan DBManager (Menu \sphinxcode{\sphinxupquote{Database > DBManager}}) pada QGIS untuk mengakses PostGIS,

Selanjutnya, buat query\sphinxhyphen{}query berikut ini. Sesuaikan atribut dan nama kolom dengan data yang digunakan.
\begin{itemize}
\item {} 
Mencari titik\sphinxhyphen{}titik penting (POI) yang berada pada kawasan rawan bencana:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{n}{poi}\PYG{p}{.}\PYG{n}{id\PYGZus{}0}\PYG{p}{,} \PYG{n}{poi}\PYG{p}{.}\PYG{n}{geom}
\PYG{k}{from} \PYG{n}{poi}\PYG{p}{,} \PYG{n}{krb}
\PYG{k}{where}  \PYG{n}{st\PYGZus{}within}\PYG{p}{(}\PYG{n}{poi}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,}\PYG{n}{krb}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{o}{=} \PYG{k}{True}
\end{sphinxVerbatim}

hasilnya,

\sphinxincludegraphics{{2020-12-03-13-06-55}.png}

\item {} 
Buffer jalan utama sejauh 100 meter

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{n}{id}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{n}{st\PYGZus{}buffer}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)} \PYG{k}{from} \PYG{n}{jalan}
\PYG{k}{where} \PYG{k}{type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}primary\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Menampilkan jumlah bangunan pendidikan di berbah

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{k}{count}\PYG{p}{(}\PYG{n}{id\PYGZus{}0}\PYG{p}{)} \PYG{k}{as} \PYG{n}{jumlah}
\PYG{k}{from} \PYG{n}{poi}
\PYG{k}{where} \PYG{n}{st\PYGZus{}within}\PYG{p}{(}\PYG{n}{poi}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{p}{(}
\PYG{k}{select} \PYG{n}{geom}
\PYG{k}{from} \PYG{n}{kecamatan}
\PYG{k}{where} \PYG{n}{kec} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Berbah\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{and} \PYG{n}{fungsi} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Pendidikan\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Total Panjang Jalan utama di Kecamatan Berbah

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{k}{sum}\PYG{p}{(}\PYG{n}{st\PYGZus{}length}\PYG{p}{(}\PYG{n}{jalan}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} \PYG{k}{as} \PYG{n}{total}
\PYG{k}{from} \PYG{n}{jalan}\PYG{p}{,} \PYG{n}{kecamatan}
\PYG{k}{where} \PYG{n}{jalan}\PYG{p}{.}\PYG{k}{type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}primary\PYGZsq{}} \PYG{k}{and} \PYG{n}{st\PYGZus{}intersects}\PYG{p}{(}\PYG{n}{jalan}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,}
\PYG{p}{(}\PYG{k}{select} \PYG{n}{geom} \PYG{k}{from} \PYG{n}{kecamatan} \PYG{k}{where} \PYG{n}{kec} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Berbah\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Mencari jalan yang berjarak 5 kilometer dari STIE YKPN

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{n}{jalan}\PYG{p}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{jalan}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{jalan}\PYG{p}{.}\PYG{k}{type} 
\PYG{k}{from} \PYG{n}{jalan}\PYG{p}{,} \PYG{n}{poi} 
\PYG{k}{where} \PYG{n}{ST\PYGZus{}DWithin}\PYG{p}{(}\PYG{n}{poi}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{jalan}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{5000}\PYG{p}{)}
\PYG{k}{and} \PYG{n}{poi}\PYG{p}{.}\PYG{n}{nama} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}STIE YKPN\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Mencari kecamatan paling luas di Kabupaten Sleman

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{n}{kec}\PYG{p}{,} \PYG{n}{st\PYGZus{}area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{as} \PYG{n}{luas}
\PYG{k}{from} \PYG{n}{kecamatan} 
\PYG{k}{where} \PYG{n}{st\PYGZus{}area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{in} 
\PYG{p}{(}
\PYG{k}{select} \PYG{k}{max}\PYG{p}{(}\PYG{n}{st\PYGZus{}area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} 
\PYG{k}{from} \PYG{n}{kecamatan} 
\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Menampilkan ruas jalan terpanjang di Kecamatan Berbah

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{n}{name}\PYG{p}{,} \PYG{n}{st\PYGZus{}length}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{as} \PYG{n}{panjang}
\PYG{k}{from} \PYG{n}{jalan} 
\PYG{k}{where} \PYG{n}{st\PYGZus{}length}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{in} 
\PYG{p}{(}
\PYG{k}{select} \PYG{k}{max}\PYG{p}{(}\PYG{n}{st\PYGZus{}length}\PYG{p}{(}\PYG{n}{jalan}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}\PYG{p}{)} 
\PYG{k}{from} \PYG{n}{jalan}\PYG{p}{,} \PYG{n}{kecamatan} 
\PYG{k}{where} \PYG{n}{st\PYGZus{}intersects}\PYG{p}{(}\PYG{n}{jalan}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{kecamatan}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{and} \PYG{n}{kec}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}Berbah\PYGZsq{}} 
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxincludegraphics{{2020-12-03-13-04-59}.png}

\item {} 
Mencari kecamatan yang dilewati oleh Jalan Kabupaten

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{n}{kec} 
\PYG{k}{from} \PYG{n}{kecamatan}\PYG{p}{,} \PYG{n}{jalan} 
\PYG{k}{where} \PYG{n}{st\PYGZus{}intersects}\PYG{p}{(}\PYG{n}{jalan}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{,}\PYG{n}{kecamatan}\PYG{p}{.}\PYG{n}{geom}\PYG{p}{)}
\PYG{k}{and} \PYG{n}{jalan}\PYG{p}{.}\PYG{n}{geom} \PYG{k}{in} \PYG{p}{(}\PYG{k}{select} \PYG{n}{geom} 
\PYG{k}{from} \PYG{n}{jalan} 
\PYG{k}{where} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}Jln. Kabupaten\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxincludegraphics{{2020-12-03-13-04-38}.png}

\item {} 
Mencari luas Hutan

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{n}{st\PYGZus{}area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{as} \PYG{n}{luas} \PYG{k}{from} \PYG{n}{gunalahan} 
\PYG{k}{where} \PYG{n}{guna\PYGZus{}lahan}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}HUTAN\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxincludegraphics{{2020-12-03-13-04-23}.png}

\item {} 
Mencari jumlah bangunan di area KRB III

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{select} \PYG{n}{st\PYGZus{}area}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)} \PYG{k}{as} \PYG{n}{luas} \PYG{k}{from} \PYG{n}{krb} 
\PYG{k}{where} \PYG{n}{id} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}3\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxincludegraphics{{2020-12-03-13-04-11}.png}

\end{itemize}

Untuk latihan lanjutan, coba lakukan Query berikut:
\begin{itemize}
\item {} 
Menampilkan jumlah titik penting yang berada di kecamatan Berbah

\item {} 
Menampilkan Bangunan dengan luas lebih dari 1500 m2

\item {} 
Menampilkan keliling Kecamatan Cangkringan

\item {} 
Menampilkan panjang jalan kaliurang

\item {} 
Menampilkan panjang total semua sungai

\end{itemize}


\subsubsection{Latihan: Query Spasial pada Raster}
\label{\detokenize{sesi2/postgisquery:latihan-query-spasial-pada-raster}}
Berikut contoh analisis raster dengan PostGIS:
\begin{itemize}
\item {} 
Membuat tingkat kepadatan penduduk pada kecamatan Berbah

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{klasifikasi} \PYG{p}{(}\PYG{n}{rid} \PYG{n+nb}{SERIAL} \PYG{k}{primary} \PYG{k}{key}\PYG{p}{,} \PYG{n}{rast} \PYG{n}{raster}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{klasifikasi} \PYG{p}{(}\PYG{n}{rast}\PYG{p}{)} 
\PYG{k}{with} \PYG{n}{Berbah} \PYG{k}{as}
	 \PYG{p}{(}\PYG{k}{Select} \PYG{n}{geom} \PYG{k}{from} \PYG{n}{kecamatan} \PYG{k}{where} \PYG{n}{kec}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}Berbah\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
         \PYG{n}{klip} \PYG{k}{as}
	 \PYG{p}{(}\PYG{k}{Select} \PYG{n}{ST\PYGZus{}Clip}\PYG{p}{(}\PYG{n}{rast}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{k}{true}\PYG{p}{)} \PYG{k}{as} \PYG{n}{rast} \PYG{k}{from} \PYG{n}{rstdem}\PYG{p}{,} \PYG{n}{berbah} \PYG{k}{where} \PYG{n}{st\PYGZus{}intersects}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{n}{rast}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{select} \PYG{n}{st\PYGZus{}reclass}\PYG{p}{(}\PYG{n}{rast}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}0\PYGZhy{}50:1, 51\PYGZhy{}100:2, 101\PYGZhy{}150:3, 151\PYGZhy{}200:4\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}4BUI\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{from} \PYG{n}{klip}\PYG{p}{;}
\PYG{k}{SELECT} \PYG{n}{AddRasterConstraints}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}klasifikasi\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}rast\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxincludegraphics{{2020-12-03-13-11-23}.png}
\begin{itemize}
\item {} 
Rencana Lokasi perumahan di Kecamatan Kalasan
Dibuat kondisi sebagai berikut:

\end{itemize}
\begin{itemize}
\item {} 
Penggunaan lahan berupa sawah irigasi atau tegalan

\item {} 
Berada pada daerah Kecamatan Kalasan

\item {} 
Kemiringan lereng tidak lebih dari 0.1 radian
Dibuat query sebagai berikut:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE} \PYG{k}{TABLE} \PYG{n}{perumahan} \PYG{p}{(}\PYG{n}{rid} \PYG{n+nb}{SERIAL} \PYG{k}{primary} \PYG{k}{key}\PYG{p}{,} \PYG{n}{rast} \PYG{n}{raster}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{INSERT} \PYG{k}{INTO} \PYG{n}{perumahan}\PYG{p}{(}\PYG{n}{rast}\PYG{p}{)}

\PYG{k}{with} \PYG{n}{kalasan} \PYG{k}{as}
		\PYG{p}{(}\PYG{k}{select} \PYG{n}{geom} \PYG{k}{from} \PYG{n}{kecamatan} \PYG{k}{where} \PYG{n}{kec}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}Kalasan\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
	\PYG{n}{sawah} \PYG{k}{as}
		\PYG{p}{(}\PYG{k}{select} \PYG{n}{geom} \PYG{k}{from} \PYG{n}{gunalahan} \PYG{k}{where} \PYG{n}{guna\PYGZus{}lahan}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}SAWAH IRIGASI\PYGZsq{}} \PYG{k}{or} \PYG{n}{guna\PYGZus{}lahan}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}TEGALAN\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
	\PYG{n}{potong1} \PYG{k}{as}
		\PYG{p}{(}\PYG{k}{select}  \PYG{n}{ST\PYGZus{}Clip}\PYG{p}{(}\PYG{n}{rast}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{k}{true}\PYG{p}{)} \PYG{k}{as} \PYG{n}{rast} \PYG{k}{from} \PYG{n}{rstdem}\PYG{p}{,} \PYG{n}{kalasan} \PYG{k}{where} \PYG{n}{st\PYGZus{}intersects}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{n}{rast}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
	\PYG{n}{lereng} \PYG{k}{as}
		\PYG{p}{(}\PYG{k}{select} \PYG{n}{ST\PYGZus{}Slope}\PYG{p}{(}\PYG{n}{rast}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}32BF\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{rast} \PYG{k}{from} \PYG{n}{potong1}\PYG{p}{)}\PYG{p}{,}
	\PYG{n}{kelas\PYGZus{}lereng} \PYG{k}{as}
		\PYG{p}{(}\PYG{k}{select} \PYG{n}{st\PYGZus{}reclass}\PYG{p}{(}\PYG{n}{rast}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}0\PYGZhy{}0.09:1\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}4BUI\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{as} \PYG{n}{rast} \PYG{k}{from} \PYG{n}{lereng}\PYG{p}{)}
	
\PYG{k}{SELECT}  \PYG{n}{ST\PYGZus{}Clip}\PYG{p}{(}\PYG{n}{rast}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{k}{true}\PYG{p}{)} \PYG{k}{from} \PYG{n}{kelas\PYGZus{}lereng}\PYG{p}{,} \PYG{n}{sawah} \PYG{k}{where} \PYG{n}{st\PYGZus{}intersects}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,}\PYG{n}{rast}\PYG{p}{)}\PYG{p}{;}
	
\PYG{k}{SELECT} \PYG{n}{AddRasterConstraints}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}perumahan\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}rast\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{name}\PYG{p}{)}\PYG{p}{;}	
\end{sphinxVerbatim}

hasilnya:

\sphinxincludegraphics{{2020-12-03-13-12-33}.png}


\chapter{Pengantar Interoperabilitas Data Spasial}
\label{\detokenize{sesi3/introogc:pengantar-interoperabilitas-data-spasial}}\label{\detokenize{sesi3/introogc::doc}}
Proses bisnis Sistem Informasi Geospasial saat ini tidak terbatas pada aktivitas akuisisi data, penyimpanan, pengolahan dan visualisasi pada sebuah sistem tunggal. Kebutuhan tukar\sphinxhyphen{}guna data semakin besar pada sebuah ekosistem Enterprise GIS, sehingga diperlukan adanya mekanisme yang memungkinkan data spasial dengan segala propertinya. Pada bagian ini akan dibahas mengenai konsep interoperabilitas dan implementasinya menggunakan perangkat server data spasial.

Bagian ini membahas mengenai:

 {\hyperref[\detokenize{sesi3/interoperabilitas::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Interoperabilitas dan Standar OGC}}}}
: Konsep interoperabilitas data spasial dengan standar OGC dan instalasi server data spasial menggunakan Geoserver

 {\hyperref[\detokenize{sesi3/publikasi::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Publikasi data spasial dengan OGC}}}}
: Bagaimana mengatur geoserver untuk publikasi data spasial sesuai dengan standar OGC, mengatur sistem proyeksi data, dan membuat tiling untuk data citra satelit

 {\hyperref[\detokenize{sesi3/konsumsiogc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Pengaturan dan Konsumsi data spasial melalui OGC}}}}
: Setelah melakukan publikasi data pada OGC, beberapa client berbeda (QGIS, LeafletJS, OpenLayers, Mapstore) digunakan untuk memanggil data tersebut






\section{Interoperabilitas dan Standar OGC}
\label{\detokenize{sesi3/interoperabilitas:interoperabilitas-dan-standar-ogc}}\label{\detokenize{sesi3/interoperabilitas::doc}}
Kebutuhan untuk berbagi pakai data spasial semakin meningkat seiring dengan \sphinxhref{https://www.gislounge.com/80-percent-data-is-geographic/}{berkembangnya kebutuhan akan data dan informasi geospasial} itu sendiri. Dengan beragamnya format data dan vendor aplikasi yang digunakan di berbagai instansi, perlu adanya suatu standar yang dapat digunakan untuk menjamin agar data spasial yang dibagikan antar instansi dapat digunakan secara optimal. Pada bagian ini akan dibahas mengenai standar pertukaran data spasial untuk menjamin interoperabilitas data spasial


\subsection{Kebijakan Satu Peta dan Interoperabilitas Data Spasial}
\label{\detokenize{sesi3/interoperabilitas:kebijakan-satu-peta-dan-interoperabilitas-data-spasial}}
Wacana mengenai kebijakan satu peta telah dimulai sejak tahun 2010 di Indonesia. Meskipun Indonesia merupakan salah satu negara \sphinxstyleemphasis{early\sphinxhyphen{}adopters} untuk inrastruktur data spasial, baru pada tahun 2011 melalui Undang\sphinxhyphen{}Undang Informasi Geospasial (UUIG) wujud Infrastruktur Data Spasial yang digunakan untuk berbagi pakai data antar instansi ini mulai terlihat.


\subsubsection{Interoperabilitas Data Spasial}
\label{\detokenize{sesi3/interoperabilitas:interoperabilitas-data-spasial}}
Berbagai instansi di Indonesia menggunakan data spasial pada berbagai level. Sebagai produser atau pemilik data spasial pada domain masing\sphinxhyphen{}masing, tiap instansi menggunakan format data dan perangkat lunak yang berbeda. Hal ini berakibat pada sulitnya berbagi pakai data antar instansi. Terlebih lagi, data spasial memiliki karakteristik yang berbeda dibandingkan dengan data biasa, seperti adanya sistem proyeksi, geometri, topologi yang mendefinisikan data tersebut. Pertukaran data pada berbagai vendor yang berbeda dengan format data masing\sphinxhyphen{}masing berpotensi mengakibatkan \sphinxstyleemphasis{loss of information}, dan dalam kasus data spasial, dapat menyebabkan pengambilan keputusan yang salah.

\sphinxstyleemphasis{Fair Principle} (\sphinxstyleemphasis{Findable, Accessible, Interoperable} dan \sphinxstyleemphasis{Reuseable}) digunakan untuk menjamin agar data spasial dapat digunakan oleh berbagai aktor yang berbeda. Prinsip FAIR memungkinan format data dari berbagai instansi yang berbeda untuk dapat digunakan tanpa hilangnya informasi penting terkait data tersebut. Pada data spasial, implementasi FAIR principle merupakan kebutuhan utama pada Infrastruktur Data Spasial, dimana data geospasial antar wali data yang berbeda dapat saling digunakan satu dengan yang lain.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2020-12-04-03-46-57}.png}
\caption{Prinsip FAIR}\label{\detokenize{sesi3/interoperabilitas:fairprinciple}}\end{figure}


\subsection{Standar OGC}
\label{\detokenize{sesi3/interoperabilitas:standar-ogc}}
\sphinxhref{https://www.ogc.org/standards}{Standar OGC} dikembangkan oleh para anggota untuk membuat informasi dan layanan geospasial memenuhi prinsip FAIR \sphinxhyphen{} Findable, Accessible, Interoperable, dan Reuseable. Standar digunakan oleh pengembang perangkat lunak untuk membangun antarmuka terbuka dan pengkodean ke dalam produk dan layanan masing\sphinxhyphen{}masing vendor. Standar adalah “produk” utama OGC dan telah dikembangkan oleh member OGC untuk mengatasi tantangan interoperabilitas tertentu, seperti menerbitkan konten peta di Web, bertukar data lokasi penting selama tanggap bencana \& pemulihan, dan memungkinkan penggabungan informasi dari beragam konten Internet of Things (IoT).


\subsubsection{OGC untuk interoperabilitas}
\label{\detokenize{sesi3/interoperabilitas:ogc-untuk-interoperabilitas}}
OGC mengikuti Spesifikasi OpenGIS yang mendefinisikan bagaimana data spasial disimpan dan direpresentasikan. Standar Simple Feature Spesification ini menjadi acuan bagi OGC dan berbagai perangkat lunak yang mendefinisikan data spasial sehingga memungkinkan satu interpretasi yang sama pada fitur yang direpresentasikan oleh data spasial yang dimaksud. Simple Feature didefinisikan sebagai berikut:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-04-03-48-23}.png}
\caption{Simple Feature Specification}\label{\detokenize{sesi3/interoperabilitas:sfs}}\end{figure}

Berbagai standar OGC dibuat untuk memungkinkan data\sphinxhyphen{}data spasial yang beragam dari berbagai domain untuk dapat digunakan mengikuti prinsip FAIR sesuai dengan format yang juga didefinisikan oleh OGC. Dengan tujuan untuk memungkinkan data spasial dapat disajikan melalui internet, standar ini juga menjamin prinsip FAIR melalui penggunaan metadata dan data dalam bentuk layanan (\sphinxstyleemphasis{services}). Layanan inilah yang digunakan untuk meng\sphinxhyphen{}onlinekan data spasial agar dapat digunakan oleh aktor yang berbeda agar dapat menggunakan data spasial dengan semua karakteristiknya.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-04-03-49-43}.png}
\caption{OGC Data \& Metadata Services}\label{\detokenize{sesi3/interoperabilitas:ogcservice}}\end{figure}

Terdapat puluhan standar OGC berbeda yang digunakan untuk berbagai keperluan. Standar untuk layanan dan format data diatur tersendiri. Demikian pula standar untuk memungkinkan Discovery atau pencarian data spasial pada portal untuk menjamin prinsip Findable dan Accessible. Berikut adalah standar terkait dengan Discovery, Container, serta layanan dan API.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-04-06-07-31}.png}
\caption{Standar OGC untuk Discovery, Container, Service dan API}\label{\detokenize{sesi3/interoperabilitas:standarogcdiscovery}}\end{figure}

Berikut standar OGC untuk Model data dan Sensor:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-04-06-09-08}.png}
\caption{Standar OGC untuk Model Data dan Sensor}\label{\detokenize{sesi3/interoperabilitas:standarogcmodel}}\end{figure}

Tiap standar tersebut memiliki fungsi dan fitur yang berbeda. Pada bagian selanjutnya akan dibahas mengenai WMS, WFS dan WCS yang merupakan standar yang umum dijumpai saat ini.


\subsubsection{WMS WFS dan WCS}
\label{\detokenize{sesi3/interoperabilitas:wms-wfs-dan-wcs}}
Dari ratusan standar yang berbeda, beberapa standar digunakan lebih sering dibandingkan yang lain karena kebutuhan untuk representasi data menggunakan standar ini cukup besar. WMS digunakan untuk pertukaran data vektor dan raster, WFS untuk data vektor dan WCS untuk data raster. Ketiga standar ini memiliki spesifikasi yang berbeda untuk digunakan pada kebutuhan yang berbeda pula.
\begin{itemize}
\item {} 
\sphinxstylestrong{Web Map Service (WMS)}
WMS merupakan standar yang dibuat untuk memungkinkan akses data spasial baik dalam format raster maupun vektor untuk disajikan sebagai Image. Pada data masukan berupa raster, WMS mengkonversi nilai pixel dan format data masukan menjadi format data yang lebih ringkas untuk digunakan melalui web (misalnya png atau jpg) sehingga nilai pixel aslinya hilang.

\sphinxincludegraphics{{2020-12-04-06-29-02}.png}

Untuk data vector, WMS mengkonversi data tersebut menjadi raster untuk keperluan tampilan, dimana simbologi pada layer tampilan tersebut diperoleh berdasarkan styling yang dilakukan di sisi server.

\sphinxincludegraphics{{2020-12-04-06-29-27}.png}

\item {} 
\sphinxstylestrong{Web Feature Service (WFS)}
WFS digunakan untuk menyajikan data vector lengkap dengan semua propertinya (atribut, geometri, sistem proyeksi, dst). WFS digunakan apabila client menginginkan untuk mendapatkan data vector secara penuh, misalnya untuk keperluan analisis spasial. Berbeda dengan WMS yang melakukan styling pada sisi server, WFS menyajikan data biner dalam bentuk vector kepada client, sehingga kebutuhan untuk melakukan simbologi diserahkan pada pengaturan client

\sphinxincludegraphics{{2020-12-04-06-30-34}.png}

\item {} 
\sphinxstylestrong{Web Coverage Service (WCS)}
WCS berbeda dengan WMS dalam hal penyajian informasi detil dari sebuah citra. Jika WMS menyederhanakan nilai pixel pada raster menjadi nilai RGB sesuai dengan tampilannya, maka WCS menjaga nilai pixel dan band dari raster masukan sehingga client dapat menggunakan data tersebut untuk analisis raster. Contoh penggunaan WCS adalah untuk menampilkan raster elevasi yang memungkinkan pengguna untuk melakukan analisis seperti slope atau aspect.

\end{itemize}

Berikut adalah contoh skenario penggunaan ketiga jenis layanan tersebut:

Sebagai contoh, dibuat sebuah WebGIS Desa yang memanfaatkan data dari berbagai sumber sebagai berikut:
\begin{itemize}
\item {} 
WMS Citra SPOT 6 desa dari Badan Informasi Geospasial sebagai latar belakang

\item {} 
WMS Batas Desa dari BPS sebagai latar belakang

\item {} 
WFS Jaringan Jalan dari PU untuk analisis buffer

\item {} 
WFS bangunan desa dari server local untuk simbologi atribut

\item {} 
WCS raster ketinggian (elevasi) DEMNAS dari BIG

\item {} 
WCS raster cuaca terkini dari BIG

\end{itemize}

Dengan menggunakan layanan OGC, data dari berbagai sumber dapat digabungkan pada satu platform yang sama, sekaligus memungkinkan analisis dan visualisasi dari data yang berbeda. Ini merupakan implementasi interoperabilitas pada Prinsip FAIR.


\subsection{Moving Forward}
\label{\detokenize{sesi3/interoperabilitas:moving-forward}}
Standar OGC mengatur pertukaran data spasial pada domain utama, khususnya terkait dengan berbagai format data baik raster maupun vektor. Seiring perkembangan teknologi, khususnya trend pengolahan data berbasis \sphinxstyleemphasis{cloud} dan Analysis Ready Data maupun perkembangan teknologi internet itu sendiri, terdapat beberapa standar lain yang saat ini berkembang untuk memungkinkan beragam aplikasi di luar standar yang disediakan oleh OGC saat ini. Beberapa diantaranya adalah seperti berikut:


\subsubsection{Cloud Optimised GeoTIFF (COG)}
\label{\detokenize{sesi3/interoperabilitas:cloud-optimised-geotiff-cog}}
\sphinxincludegraphics{{2020-12-04-04-22-28}.png}

Cloud Optimized GeoTIFF (COG) mirip dengan file GeoTIFF biasa tetapi dengan organisasi internal yang memungkinkan akses baca yang lebih efisien ke sebagian gambar, alur kerja yang paling umum untuk mengakses citra yang disimpan di infrastruktur cloud. Hal ini dilakukan dengan memanfaatkan kemampuan klien yang mengeluarkan permintaan rentang HTTP GET untuk meminta hanya bagian dari file yang mereka butuhkan. Teknologi yang sangat mirip yang memungkinkan Anda untuk langsung mulai menonton video streaming memungkinkan analisis pada GeoTIFF besar tanpa perlu mengunduh seluruh file.
Sementara beberapa standar berbeda telah mengatasi masalah ini, COG berada pada posisi yang baik untuk menjadi standar komunitas dan industri. Dukungan untuk standar baru dengan cepat diintegrasikan ke dalam pustaka perangkat lunak sumber terbuka dan mempertahankan kompatibilitas ke belakang; sistem yang dapat melihat file TIFF biasa juga dapat melihat COG, meskipun sistem tersebut tidak memanfaatkan pembacaan rentang byte HTTP atau komponen geospasial. COG adalah GeoTIFFS adalah TIFF. Dalam waktu singkat sejak dikembangkan, format COG dengan cepat diadopsi oleh penyedia citra observasi Bumi karena ini merupakan cara untuk dengan mudah mengurangi biaya transfer jaringan dalam infrastruktur terdistribusi.


\subsubsection{Spatio Temporal Asset Catalog (STAC)}
\label{\detokenize{sesi3/interoperabilitas:spatio-temporal-asset-catalog-stac}}
\sphinxincludegraphics{{2020-12-04-04-27-12}.png}

Spesifikasi SpatioTemporal Asset Catalog (STAC) bertujuan untuk menstandarkan bagaimana data geospasial diekspos secara online dan di\sphinxstyleemphasis{query}. ‘Aset spasiotemporal’ adalah file apa pun yang mewakili informasi tentang bumi yang ditangkap dalam ruang dan waktu tertentu. Fokus awal utamanya adalah citra penginderaan jarak jauh (dari satelit, tetapi juga pesawat, drone, balon, dll.), tetapi intinya dirancang agar dapat diperluas ke SAR, FMV, Point\sphinxhyphen{}cloud, hiperspektral, LiDAR, dan data turunan seperti NDVI , Model Elevasi Digital, mozaik, dll.

Tujuan STAC adalah agar semua penyedia utama citra dan data observasi bumi lainnya mengekspos data mereka sebagai Katalog Aset SpatioTemporal, sehingga kode baru tidak perlu ditulis setiap kali REST API berbasis JSON baru keluar yang membuat datanya tersedia di dengan cara yang sedikit berbeda. Ini akan mengaktifkan komponen pustaka standar dalam banyak bahasa. STAC juga dapat diimplementasikan dengan cara yang sepenuhnya ‘statis’, memungkinkan penerbit data mengekspos data mereka hanya dengan menerbitkan file JSON yang ditautkan secara online.

Kedua standar tersebut mendukung penggunaan citra dan analisis citra pada cloud, tanpa perlu mengunduh satupun data pada komputer lokal. Rilis terbaru Landsat Collection 2 telah menggunakan \sphinxhref{https://prd-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/atoms/files/LSDS-1388-Landsat-Cloud-Optimized-GeoTIFF\_DFCB-v2.0.pdf}{standar COG dan STAC}, dan menunjukkan \sphinxhref{https://www.usgs.gov/core-science-systems/nli/landsat/landsat-data-access?qt-science\_support\_page\_related\_con=0\#qt-science\_support\_page\_related\_con}{arah penggunaan format data yang lebih terbuka} untuk mendukung interoperabilitas data spasial.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-04-04-33-50}.png}
\caption{Landsat telah mengumumkan rilis untuk Collection 2 yang menggunakan STAC dan COG sebagai metode delivery data citra}\label{\detokenize{sesi3/interoperabilitas:landsatcol2}}\end{figure}


\subsubsection{Standar Baru untuk Dunia Baru: OGC\sphinxhyphen{}API}
\label{\detokenize{sesi3/interoperabilitas:standar-baru-untuk-dunia-baru-ogc-api}}
Standar seperti WMS, WFS dan WCS dibuat berdasarkan standar dan teknologi internet yang berlaku pada awal tahun 2000an. Dengan perkembangan teknologi saat ini serta perubahan paradigma data spasial pada web, OGC mengusulkan serangkaian standar baru untuk menggantikan standar WMS, WFS, dst yang digunakan saat ini.

Berikut adalah beberapa standar OGC\sphinxhyphen{}API yang sedang diusulkan:
\begin{itemize}
\item {} 
OGC API \sphinxhyphen{} Common (OWS Common)

\item {} 
OGC API \sphinxhyphen{} Features (former WFS)

\item {} 
OGC API \sphinxhyphen{} Coverages (former WCS)

\item {} 
OGC API \sphinxhyphen{} Maps (former WMS)

\item {} 
OGC API \sphinxhyphen{} Tiles (former WMTS)

\item {} 
OGC API \sphinxhyphen{} Processing (former WPS)

\item {} 
OGC API \sphinxhyphen{} Records (former CSW)

\end{itemize}

OGC\sphinxhyphen{}API saat ini sedang dalam \sphinxhref{https://ogcapi.ogc.org/apiroadmap.html}{tahap pengembangan aktif}, dan prosedur migrasi dari standar lama (WMS, WFS, WCS, dst) sedang disiapkan. Beberapa aplikasi, seperti PyGeoAPI dikembangkan untuk keperluan ini. PyGeoAPI merupakan salah satu prototip aplikasi yang dikembangkan untuk mendukung Standar OGC API yang baru. Saat ini, PyGeoAPI telah diujicobakan dan berhasil digunakan untuk mendukung infrastruktur data spasial di beberapa negara.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{2020-12-04-03-55-05}.png}
\caption{Arsitektur PyGeoAPI}\label{\detokenize{sesi3/interoperabilitas:pygeoapi}}\end{figure}


\subsection{Server Data Spasial: Geoserver}
\label{\detokenize{sesi3/interoperabilitas:server-data-spasial-geoserver}}
\sphinxhref{http://geoserver.org/}{Geoserver} merupakan aplikasi Server Data Spasial yang mendukung publikasi berbagai macam jenis data spasial menjadi format yang didukung oleh OGC. Geoserver seringkali digunakan bersamaan dengan aplikasi lain sebagai bagian dari sebuah sistem informasi spasial, web GIS atau infrastruktur data spasial untuk memastikan data spasial dapat digunakan pada berbagai sistem yang berbeda dan menjamin interoperabilitas.


\subsubsection{Latihan: Instalasi Geoserver}
\label{\detokenize{sesi3/interoperabilitas:latihan-instalasi-geoserver}}
Pada bagian ini akan dibahas mengenai cara instalasi Geoserver: melalui aplikasi servlet seperti Tomcat, serta menggunakan paket aplikasi yang tersedia pada Docker.
\begin{itemize}
\item {} 
\sphinxstylestrong{Cara 1: menggunakan Docker}
Pada bagian ini, akan digunakan Docker sebagai media instalasi Geoserver. Sebelumnya telah dibahas bagaimana Docker dapat mempermudah instalasi berbagai aplikasi. Berikut adalah panduannya:

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Dengan cara pertama ini, dapat digunakan berbagai Image Geoserver yang tersedia pada Docker Hub. Untuk latihan ini akan digunakan image yang dibuat oleh \sphinxhref{https://github.com/kartoza/docker-geoserver}{Kartoza}, sama seperti PostGIS pada materi sebelumnya.

\item {} 
Jalankan perintah berikut untuk menginstall Geoserver pada port 8080 menggunakan Docker:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker run \PYGZhy{}d \PYGZhy{}p \PYG{l+m}{8080}:8080 \PYGZhy{}\PYGZhy{}name geoserver kartoza/geoserver:latest 
\end{sphinxVerbatim}

Maka Geoserver akan diunduh dan dijalankan pada Localhost:8080.

Cara ini akan mengunduh Geoserver berikut seluruh kelengkapannya (extensi standar maupun community, dokumentasi dan sampel data), sehingga ukuran unduhan akan cukup besar. Untuk instalasi Geoserver dengan ukuran yang lebih kecil untuk keperluan latihan ini, gunakan Cara Kedua di bawah ini.

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxstylestrong{Cara 2: Melalui Tomcat}
Pada latihan ini, akan dibuat instalasi baru Geoserver dengan menggunakan Tomcat yang telah diinstall pada latihan berikutnya, sehingga terlebih dahulu perlu dipastikan bahwa instalasi Tomcat telah berhasil dan Tomcat berhasil dijalankan.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Unduh Geoserver dari website resminya: \sphinxurl{http://geoserver.org/release/stable/}
Untuk latihan ini, yang diunduh adalah build Geoserver dengan format Web Archive (WAR). Karena unduhan akan dilakukan pada mesin WSL, maka cukup copykan link yang mengarah pada Web Archive tersebut:

\sphinxincludegraphics{{2020-12-04-06-51-38}.png}

dalam hal ini, linknya adalah:

\sphinxurl{http://sourceforge.net/projects/geoserver/files/GeoServer/2.18.1/geoserver-2.18.1-war.zip}

 

\item {} 
Buka WSL, kemudian pada folder dimana kita memiliki akses untuk menulis, jalankan perintah berikut

\begin{sphinxVerbatim}[commandchars=\\\{\}]
wget http://sourceforge.net/projects/geoserver/files/GeoServer/2.18.1/geoserver\PYGZhy{}2.18.1\PYGZhy{}war.zip
\end{sphinxVerbatim}

 

\sphinxincludegraphics{{2020-12-04-06-53-48}.png}

 

perintah tersebut akan mengunduh file zip dengan nama: \sphinxcode{\sphinxupquote{geoserver\sphinxhyphen{}2.18.1\sphinxhyphen{}war.zip}} (sesuaikan nama berkas jika menggunakan versi yang berbeda)

 

\item {} 
Lakukan ekstraksi file zip hasil unduhan pada folder aktif Tomcat.
Pada Ubuntu, Tomcat menggunakan folder \sphinxcode{\sphinxupquote{/opt/tomcat/latest/webapps}} (sebagaimana pengaturan softlink yang telah dibuat pada saat instalasi) untuk mempublikasikan aplikasi WAR. Gunakan perintah berikut untuk mengextract zip ke dalam folder tersebut:

Install \sphinxcode{\sphinxupquote{unzip}} terlebih dahulu:
\sphinxcode{\sphinxupquote{sudo apt install unzip}}, kemudian:

 

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 sudo unzip \PYGZhy{}o geoserver\PYGZhy{}2.18.1\PYGZhy{}war.zip \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}/opt/tomcat/latest/webapps/\PYGZdq{}}
\end{sphinxVerbatim}

 

\item {} 
Jika belum, aktifkan Tomcat menggunakan perintah:

 

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo systemctl start tomcat
\end{sphinxVerbatim}

 

Tunggu sampai beberapa saat pada saat Tomcat melakukan ekstraksi file WAR tersebut.

 

\item {} 
Buka browser pada Windows di alamat: \sphinxcode{\sphinxupquote{localhost:8080/geoserver}}
\sphinxincludegraphics{{2020-12-04-07-15-07}.png}

\end{enumerate}

 

Cara yang sama dapat digunakan untuk aplikasi berbasis Java Web Archive lain, seperti \sphinxhref{https://mapstore.readthedocs.io/en/latest/}{Mapstore} atau \sphinxhref{https://geonetwork-opensource.org/}{Geonetwork}. Instalasi melalui WAR ini akan memberikan kita kontrol penuh pada aplikasi, seperti pengaturan SSL, CORS, dan lain sebagainya. Demikian pula, deployment pada Tomcat memungkinkan beberapa aplikasi sekaligus untuk dapat diinstall pada port yang sama (Port 8080), sehingga cara inilah yang akan digunakan dalam latihan ini.

Selanjutnya, Geoserver siap digunakan untuk mengunggah data. Berikut adalah antarmuka Geoserver dengan menggunakan username: \sphinxcode{\sphinxupquote{admin}} dan password \sphinxcode{\sphinxupquote{geoserver}}.

\sphinxincludegraphics{{2020-12-04-09-00-34}.png}

Pada bagian kanan adalah daftar layanan yang didukung oleh Geoserver. Semua data yang diunggah pada Geoserver akan menggunakan layanan tersebut agar dapat diakses dari berbagai client, seperti QGIS. Inilah pembahasan kita berikutnya: bagaimana melakukan publikasi data agar dapat diakses secara \sphinxstyleemphasis{interoperable} oleh client?


\section{Publikasi Data Spasial dengan Geoserver}
\label{\detokenize{sesi3/publikasi:publikasi-data-spasial-dengan-geoserver}}\label{\detokenize{sesi3/publikasi::doc}}
Web Map Server merupakan program komputer yang menghasilkan peta data yang direferensikan secara spasial dari
data dan informasi geografis. Aplikasi ini, sebagaimana dibahas sebelumnya, adalah antarmuka sederhana yang menyajikan data dalam format standar untuk ditampilkan pada aplikasi berbasis web. Berbagai protokol melibatkan sintaks kueri untuk memposting meminta layer yang diinginkan dan memperbesar jendela ke server, yang menghasilkan peta sebagai image dalam format standar (GIF, PNG atau format lain) atau sebagai format vektor (misalnya KML, GML). Data ini kemudian dapat dikonsumsi oleh berbagai client. Pada bagian ini akan dibahas mengenai bagaimana melakukan publikasi data spasial dengan Geoserver.


\subsection{Menghubungkan Geoserver dengan Data}
\label{\detokenize{sesi3/publikasi:menghubungkan-geoserver-dengan-data}}
Geoserver mengenali berbagai jenis data spasial. Adapun urutan untuk melakukan publikasi data pada Geoserver adalah sebagai berikut:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Buat \sphinxstylestrong{Workspace} baru (workspace ≈ nama project)

\item {} 
Buat \sphinxstylestrong{Store} baru sesuai jenis data (vector/raster/cascading). Pilih workspace yang telah dibuat

\item {} 
\sphinxstylestrong{Publish layer} dengan mengatur extent, proyeksi dan styling

\item {} 
Atur \sphinxstylestrong{Style} apabila diperlukan

\item {} 
Uji Layanan Layer dengan menggunakan \sphinxstylestrong{Layer Preview}

\end{enumerate}

Langkah tersebut dapat diikuti sesuai urutan pada antarmuka Geoserver berikut:
\sphinxincludegraphics{{2020-12-04-08-57-51}.png}

Berikut adalah daftar datastore yang didukung oleh Geoserver pada instalasi defaultnya:

\sphinxincludegraphics{{2020-12-04-08-55-02}.png}

Dengan menggunakan ekstensi, daftar tersebut dapat berkembang menjadi lebih banyak. Silahkan mengacu pada halaman \sphinxhref{https://docs.geoserver.org/stable/en/user/extensions/index.html}{ekstensi Geoserver} maupun \sphinxhref{https://docs.geoserver.org/stable/en/user/community/index.html}{modul komunitas} untuk melihat opsi yang tersedia.


\subsubsection{Latihan: Mengunggah Shapefile}
\label{\detokenize{sesi3/publikasi:latihan-mengunggah-shapefile}}
Geoserver membaca data yang disimpan pada Environment variable \sphinxcode{\sphinxupquote{GEOSERVER\_DATA\_DIR}}, sehingga untuk melakukan ini, kita perlu mengcopy shapefile yang akan diunggah ke dalam folder tersebut. Lokasi folder ini dapat dilihat pada bagian data directory di server status:

\sphinxincludegraphics{{2020-12-04-08-53-02}.png}

Pada gambar di atas, folder Data Directory adalah \sphinxcode{\sphinxupquote{/opt/tomcat/apache\sphinxhyphen{}tomcat\sphinxhyphen{}9.0.40/webapps/geoserver/data}}.

Masih dengan data latihan sebelumnya, kita akan gunakan layer\sphinxhyphen{}layer tersebut untuk mengunggah data pada Geoserver.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Dengan menggunakan koneksi WSL ke Windows Explorer, copykan data yang akan kita unggah ke folder di dalam WSL, misalnya \sphinxcode{\sphinxupquote{home directory}} kita. Ingat, wsl dapat dibuka dari Windows Explorer menggunakan \sphinxcode{\sphinxupquote{\textbackslash{}\textbackslash{}wsl\$}}.

\sphinxincludegraphics{{2020-12-08-13-45-12}.png}

\item {} 
Dari WSL, copykan data tersebut ke folder \sphinxcode{\sphinxupquote{GEOSERVER\_DATA\_DIR}} yang kita catat sebelumnya. Gunakan perintah \sphinxcode{\sphinxupquote{cp}} untuk mengcopy berkas ke folder yang dimaksud.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo cp \PYGZhy{}a Data\PYGZus{}Geoserver/ \PYG{l+s+s2}{\PYGZdq{}/opt/tomcat/apache\PYGZhy{}tomcat\PYGZhy{}9.0.40/webapps/geoserver/data/shpsleman/\PYGZdq{}} 
\end{sphinxVerbatim}

\end{enumerate}

Pada Geoserver, kita dapat memanggil layer tersebut pada saat publikasi layer. Pembahasan mengenai publikasi layer adalah sebagai berikut.


\subsubsection{Latihan: Melakukan Publikasi dari Shapefile}
\label{\detokenize{sesi3/publikasi:latihan-melakukan-publikasi-dari-shapefile}}
Setelah kita memiliki shapefile pada server, berkas tersebut perlu dipublikasi agar dapat diakses menggunakan Standar OGC. Berikut langkah untuk melakukan publikasi data pada Geoserver:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Membuat Workspace. Workspace pada Geoserver dapat dianggap sebagai sebuah project yang didalamnya berisi beberapa layer sekaligus. Untuk membuat workspace, gunakan menu \sphinxcode{\sphinxupquote{Workspace}} pada bagian kiri dari halaman Geoserver, kemudian Klik \sphinxcode{\sphinxupquote{Add New Workspace}}.

\sphinxincludegraphics{{2020-12-08-14-02-26}.png}

Berikan nama dan URI pada workspace tersebut. URI digunakan sebagai identitas pada saat layer yang tersimpan di dalam workspace tersebut dipanggil nantinya. Klik \sphinxcode{\sphinxupquote{Save}} untuk menyimpan workspace

\item {} 
Berpindah ke langkah selanjutnya, kita akan menghubungkan Geoserver dengan data pada direktori. Gunakan menu \sphinxcode{\sphinxupquote{Stores}} untuk menyimpan dan menghubungkan satu atau beberapa layer dengan menggunakan Geoserver. Klik pada \sphinxcode{\sphinxupquote{Add New Store}} untuk menghubungkan sumber data baru. Karena kita akan menambahkan beberapa \sphinxstylestrong{Shapefile} sekaligus, gunakan pilihan \sphinxcode{\sphinxupquote{Directory of Spatial Files (shapefiles)}} seperti berikut:

\sphinxincludegraphics{{2020-12-08-14-07-57}.png}

klik OK untuk konfirmasi penambahan \sphinxstylestrong{Store}

\item {} 
Geoserver akan secara otomatis mengarahkan kita ke halaman layer. Selanjutnya adalah menggunakan menu ‘Publish` pada halaman tersebut untuk mempublikasikan data

\sphinxincludegraphics{{2020-12-08-14-09-30}.png}

\item {} 
Pada saat publikasi, hal yang harus diperhatikan adalah pengaturan \sphinxstylestrong{sistem proyeksi} dan \sphinxstylestrong{extent}. Pengaturan ini dapat dijumpai pada bagian akhir di halaman publikasi:

\sphinxincludegraphics{{2020-12-08-15-17-01}.png}

Terdapat tiga pengaturan penggunaan sistem proyeksi yang ada pada Geoserver:
\begin{itemize}
\item {} 
\sphinxstylestrong{Force Declared}, abaikan sistem proyeksi asli dari layer, dan berikan definisi sistem proyeksi baru pada layer tersebut. Ini dapat digunakan apabila sistem proyeksi asli dari layer hilang atau rusak, misalnya pada berkas dengan tipe \sphinxstyleemphasis{shapefile} (prj). Tool ini sama seperti \sphinxstyleemphasis{Define Projection} pada perangkat desktop

\item {} 
\sphinxstylestrong{Reproject Native to Declared}, digunakan untuk melakukan transformasi sistem proyeksi, misalnya dari sistem proyeksi UTM\sphinxhyphen{}49S (EPSG:32749) menjadi sistem proyeksi geografis (EPSG:4326). Ini sama seperti tool \sphinxstyleemphasis{Reproject} pada perangkat lunak GIS desktop

\item {} 
\sphinxstylestrong{Keep Native}, abaikan sistem proyeksi yang didefinisikan oleh Geoserver, dan gunakan sistem proyeksi asli yang terdapat pada data. Ini dapat dipilih, sebagai contoh, pada saat melakukan publikasi peta dengan sistem proyeksi lokal

\end{itemize}

\item {} 
Untuk menguji apakah layer sudah sesuai dengan keinginan, gunakan menu \sphinxcode{\sphinxupquote{Layer Preview}} pada Geoserver

\sphinxincludegraphics{{2020-12-08-16-08-26}.png}

Pada bagian ini, dapat diperiksa apakah pemanggilan WMS dan WFS untuk layer yang dipublikasi sudah sesuai. Demikian pula, dapat diperiksa mengenai kesesuaian bounding box dan sistem proyeksi yang digunakan.

\end{enumerate}

Setelah publikasi, pengaturan yang diperlukan adalah pembuatan style serta pengaturan keamanan apabila diperlukan. Bagian akhir dari bab ini membahas mengenai pengaturan style pada layer yang dapat digunakan untuk WMS pada Geoserver.


\subsubsection{Latihan: Menghubungkan Geoserver dan Basisdata PostGIS}
\label{\detokenize{sesi3/publikasi:latihan-menghubungkan-geoserver-dan-basisdata-postgis}}
PostGIS dapat dihubungkan melalui antarmuka Geoserver. Berikut adalah tampilan antarmuka dan parameter koneksinya:

\sphinxincludegraphics{{2020-12-04-08-55-41}.png}

Sama seperti pada QGIS, koneksi ke PostGIS dari Geoserver juga menggunakan parameter seperti Host, Username, Basisdata dan Password.

Setelah terkoneksi sebagai \sphinxcode{\sphinxupquote{store}}, layer pada store tersebut juga dapat ditambahkan pada Geoserver melalui Publikasi sebagaimana pada layer yang dipublikasi menggunakan Shapefile. Penggunaan PostGIS dalam hal ini memiliki beberapa keuntungan, diantaranya adalah:
\begin{itemize}
\item {} 
Keamanan data yang lebih baik, karena akses pada data dibatasi oleh Geoserver dan PostGIS sekaligus

\item {} 
Manajemen data yang fleksibel. Dengan menggunakan PostGIS, akses terhadap data dapat diatur menggunakan aplikasi framework di luar Geoserver, seperti menggunakan Laravel atau NodeJS.

\item {} 
\sphinxhref{https://geoserver.geo-solutions.it/educational/en/adding\_data/add\_sqllayers.html}{SQL View}, merupakan cara untuk memanggil layer menggunakan parameter. Sebagai contoh, kita dapat memanggil hanya layer titik yang dipilih oleh pengguna melalui bounding box, misalnya.

\end{itemize}


\subsubsection{Latihan: Publikasi Data melalui REST\sphinxhyphen{}API Geoserver}
\label{\detokenize{sesi3/publikasi:latihan-publikasi-data-melalui-rest-api-geoserver}}
Pada remote server, seringkali kita tidak dapat menggunakan antarmuka yang memungkinkan untuk publikasi data secara langsung. Boleh jadi kita tidak dapat menggunakan console pada server untuk mengcopy data pada folder Data Directory seperti yang kita lakukan sebelumnya. Dengan demikian, interaksi pada Geoserver juga menjadi terbatas. Untuk itu, Geoserver menyediakan REST API yang dapat digunakan untuk berinteraksi dengan fungsi\sphinxhyphen{}fungsi Geoserver melalui antar muka API standard. API ini dapat diakses melalui http://alamatgeoserver:8080/geoserver/\sphinxstylestrong{rest}/workspaces.

Berikut adalah langkah untuk mengunggah file pada server:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Membuat Workspace baru dengan nama \sphinxcode{\sphinxupquote{latihan}} (lewati jika Workspace sudah tersedia)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
curl \PYGZhy{}v \PYGZhy{}u admin:password \PYGZhy{}XPOST \PYGZhy{}H \PYG{l+s+s2}{\PYGZdq{}Content\PYGZhy{}type: text/xml\PYGZdq{}}  \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}workspace\PYGZgt{}\PYGZlt{}name\PYGZgt{}latihan\PYGZlt{}/name\PYGZgt{}\PYGZlt{}/workspace\PYGZgt{}\PYGZdq{}} http://alamatgeoserver:8080/geoserver/**rest**/workspaces
\end{sphinxVerbatim}

\item {} 
Mengunggah file \sphinxcode{\sphinxupquote{jalan.zip}} sebagai layer baru pada workspace \sphinxcode{\sphinxupquote{latihan}} dengan nama datastore \sphinxcode{\sphinxupquote{jalan}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
curl \PYGZhy{}v \PYGZhy{}u admin:geoserver \PYGZhy{}XPUT \PYGZhy{}H \PYG{l+s+s2}{\PYGZdq{}Content\PYGZhy{}type: application/zip\PYGZdq{}} \PYGZhy{}\PYGZhy{}data\PYGZhy{}binary @jalan.zip http://54.254.9.31:8080/geoserver/rest/workspaces/latihan/datastores/jalan/file.shp
\end{sphinxVerbatim}

\end{enumerate}

Dengan cara seperti ini, kita dapat mengunggah layer dengan format shapefile sebagai layer pada Geoserver meskipun kita tidak memiliki akses pada server tersebut secara langsung.


\subsection{Styling Publikasi dengan SLD}
\label{\detokenize{sesi3/publikasi:styling-publikasi-dengan-sld}}
Protokol WMS yang digunakan pada Geoserver memerlukan styling sebelum disajikan pada client. Format yang digunakan oleh Geoserver adalah SLD (\sphinxstyleemphasis{Style Layer Descriptor}). Antarmuka untuk pengaturan SLD adalah sebagai berikut:

\sphinxincludegraphics{{2020-12-04-08-58-42}.png}

SLD menggunakan format XML untuk menyimpan style. Untuk memudahkan styling, dapat digunakan QGIS untuk menyimpan simbolosasi yang diinginkan. Berikut adalah menu untuk melakukan \sphinxstyleemphasis{export}  Style yang dapat dilakukan pada QGIS:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Pada Properti layer di QGIS, buka simbologi, kemudian buat simbol sesuai dengan style yang diinginkan

\sphinxincludegraphics{{2020-12-08-16-01-09}.png}

Klik pada \sphinxcode{\sphinxupquote{Style > Save Style}} untuk membuka kotak dialog penyimpanan style tersebut.

\item {} 
Simpan style tersebut sebagai SLD. File inilah yang nanti akan diunggah pada antarmuka SLD di Geoserver seperti di atas

\sphinxincludegraphics{{2020-12-08-16-03-00}.png}

\end{enumerate}

Hasil publikasi dapat dikonsumsi oleh perangkat client seperti QGIS atau LeafletJS melalui alamat publikasi masing\sphinxhyphen{}masing layer sesuai standar OGC. Pembahasan ini akan diberikan pada bab selanjutnya.


\section{Konsumsi Data dengan Standar OGC}
\label{\detokenize{sesi3/konsumsiogc:konsumsi-data-dengan-standar-ogc}}\label{\detokenize{sesi3/konsumsiogc::doc}}
Dengan publikasi pada Geoserver, layer yang tersimpan tersebut akan dapat dipanggil dari berbagai macam client. Seperti tujuan awal penggunaan server data spasial, terdapat beragam client yang mendukung standar internasional OGC, sehingga dengan menggunakan standar tersebut, berbagai layanan dapat dikombinasikan dengan memperhatikan prinsip\sphinxhyphen{}prinsip FAIR. Pada bagian ini akan dibahas mengenai bagaimana menggunakan perangkat FOSS untuk mengakses layanan OGC yang disajikan dari Geoserver.


\subsection{Menggunakan Perangkat FOSS untuk mengakses data OGC}
\label{\detokenize{sesi3/konsumsiogc:menggunakan-perangkat-foss-untuk-mengakses-data-ogc}}
Berbagai perangkat FOSS dapat saling berkomunikasi dengan bantuan dukungan standar OGC. Untuk latihan ini, QGIS akan digunakan sebagai perangkat client untuk memanggil data dari Geoserver. Anda juga dipersilahkan untuk mencoba perangkat lunak lain, seperti uDIG atau gvSIG yang memiliki kemampuan serupa.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=400\sphinxpxdimen]{{2020-12-04-05-23-55}.png}
\caption{Konsumsi WMS dan WFS dari Geoserver}\label{\detokenize{sesi3/konsumsiogc:konsumsi}}\end{figure}

Standar\sphinxhyphen{}standar OGC menggunakan rangkaian parameter pada URL yang digunakan untuk memanggil berbagai layanan sesuai fungsinya, seperti WMS, WFS maupun WCS. Dari parameter inilah aplikasi client dapat digunakan untuk memanggil layanan yang dibutuhkannya. Perangkat lunak seperti QGIS dapat memanggil beragam layanan yang menggunakan standar OGC ini.


\subsubsection{Memanggil WMS, WFS dan WCS dengan QGIS}
\label{\detokenize{sesi3/konsumsiogc:memanggil-wms-wfs-dan-wcs-dengan-qgis}}
Apabila kita perhatikan, link publikasi WMS dari Geoserver adalah seperti berikut. Link ini dapat dipanggil dari Layer Preview, kemudian memilih WMS atau WFS:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
**http://localhost:8080/geoserver/Sleman/wms?**
service=WMS
\PYGZam{}version=1.1.0
\PYGZam{}request=GetMap
\PYGZam{}layers=Sleman\PYGZpc{}3ABatas\PYGZus{}Desa
\PYGZam{}bbox=413535.5625\PYGZpc{}2C9133697.0\PYGZpc{}2C450074.4375\PYGZpc{}2C9166253.0
\PYGZam{}width=768\PYGZam{}height=684
\PYGZam{}srs=EPSG\PYGZpc{}3A32749
\PYGZam{}format=image\PYGZpc{}2Fpng
\end{sphinxVerbatim}

Sedangkan berikut adalah link publikasi untuk WFS:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
**http://localhost:8080/geoserver/Sleman/ows?**
service=WFS
\PYGZam{}version=1.0.0
\PYGZam{}request=GetFeature
\PYGZam{}typeName=Sleman\PYGZpc{}3ABatas\PYGZus{}Desa
\PYGZam{}maxFeatures=50
\PYGZam{}outputFormat=application\PYGZpc{}2Fgml\PYGZpc{}2Bxml\PYGZpc{}3B\PYGZpc{}20version\PYGZpc{}3D3.2

\end{sphinxVerbatim}

Baris\sphinxhyphen{}baris di atas menunjukkan parameter yang dapat diakses dari client, dan disebut sebagai \sphinxcode{\sphinxupquote{key\sphinxhyphen{}value pair}} (KVP), dimana tiap kunci berisi parameter yang dapat diatur untuk memanggil WMS yang dimaksud (misalnya, format PNG atau JPG). Apabila kita menggunakan QGIS, parameter inilah yang akan dipanggil. QGIS telah menyediakan fungsi yang cukup lengkap untuk memanggil data dari Geoserver. Berikut caranya:

\sphinxincludegraphics{{2020-12-04-08-47-22}.png}

Tiap menu digunakan untuk memanggil layanan OGC dari jenis yang berbeda (WMS/WMTS, WFS, dan WCS). Parameter yang diperlukan untuk memanggil layer ini adalah \sphinxstyleemphasis{alamat host Geoserver}. Alamat ini adalah link bertanda tebal pada contoh KVP di atas. Misalnya untuk WMS:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{localhost}\PYG{p}{:}\PYG{l+m+mi}{8080}\PYG{o}{/}\PYG{n}{geoserver}\PYG{o}{/}\PYG{n}{Sleman}\PYG{o}{/}\PYG{n}{wms}
\end{sphinxVerbatim}

QGIS selanjutnya akan memanggil seluruh layer pada Geoserver tersebut melalui WMS GetCapabilities. Berikut adalah layer yang dipanggil dari Geoserver Geoportal Propinsi Jogja melalui WMS GetCapabilitiesnya:

\sphinxincludegraphics{{2020-12-08-16-38-57}.png}

Apabila kita panggil layer tersebut pada QGIS, kita dapat melihat perbedaan antara WMS, WFS, dan WCS seperti berikut:

\sphinxincludegraphics{{2020-12-08-16-45-50}.png}

WMS dipanggil sebagai Image atau raster, sehingga kita tidak dapat melakukan simbologi pada layer tersebut. Data atribut pada WMS dapat diakses dengan menggunakan tool \sphinxstyleemphasis{Feature Info} pada QGIS, tetapi atribut ini hanya dapat ditampilkan, dan bukan untuk dianalisis

\sphinxincludegraphics{{2020-12-08-16-47-23}.png}

WFS dipanggil sebagai vektor, sehingga kita dapat melakukan simbologi, analisis spasial, dan perlakuan lain yang dapat kita lakukan pada sebuah layer vektor biasa. Seluruh atribut dan Geometri dari layer ini dapat dipanggil.

\sphinxincludegraphics{{2020-12-08-16-48-59}.png}

Sama seperti WMS, WCS memanggil raster dari Geoserver. Perbedaannya terletak pada nilai raster yang diteruskan ke QGIS. Pada WCS, seluruh nilai raster sama seperti data aslinya, sehingga kita dapat menggunakan simbologi pada sisi client seperti gambar di atas.


\subsubsection{Memanggil data publikasi OGC dengan Javascript Library (LeafletJS)}
\label{\detokenize{sesi3/konsumsiogc:memanggil-data-publikasi-ogc-dengan-javascript-library-leafletjs}}
Pada LeafletJS (dan library web map lain seperti OpenLayers, GMap API, Mapbox dst), layer secara umum terbagi menjadi dua macam, yaitu 1) Tilelayer (‘Slippy Map’) yang dapat diperoleh dalam bentuk layanan (service) dari penyedia tile, dan 2) Feature Layer yang dapat ditambahkan sendiri pada Leaflet. Tilelayer cenderung bersifat statis, tidak interaktif dan disajikan dalam bentuk ‘tile’. Tilelayer sering digunakan sebagai background atau basemap untuk peta yang akan dibuat pada sebuah webmap library seperti Leaflet. Pada Tilelayer ini tidak dapat diterapkan konsep interaktivitas, misalnya memunculkan popup berdasarkan atribut (dengan beberapa pengecualian, misalnya pada Vector Tile).

Adapun Feature Layer merupakan layer yang dapat ditambahkan pada LeafletJS Map bersumber dari data yang kita miliki. Contoh Feature layer yang banyak dijumpai adalah Marker. Pada Marker kita dapat memberikan atribut dan menerapkan interaktivitas, misalnya dengan memunculkan popup, melakukan drag and drop, dan seterusnya. Selain marker, kita juga dapat menambahkan polygon dan polyline dengan cara yang hampir sama. Feature Layer yang lain adalah GeoJSON, yang memungkinkan kita untuk menambahkan layer data spasial lengkap dengan atribut dan fungsi interaktifnya. Pada bagian ini akan dibahas bagaimana menggunakan GeoJSON untuk menampilkan data spasial (shapefile) menjadi peta yang interaktif pada LeafletJS melalui Geoserver.

Untuk memanggil data dari Geoserver menggunakan LeafletJS, dapat digunakan script seperti berikut:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k+kd}{var} \PYG{n+nx}{layerjalan} \PYG{o}{=} \PYG{n+nx}{L}\PYG{p}{.}\PYG{n+nx}{tileLayer}\PYG{p}{.}\PYG{n+nx}{wms}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}http://localhost:8080/geoserver/wms?\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{layers}\PYG{o}{:} \PYG{l+s+s1}{\PYGZsq{}latihan:jalan\PYGZsq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{addTo}\PYG{p}{(}\PYG{n+nx}{map}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Contoh script LeafletJS tersedia pada \sphinxurl{https://github.com/danylaksono/sample-leafletjs}.

Sebagai latihan, modifikasi script tersebut untuk memanggil layer KRB yang sudah diunggah pada Geoserver WSL pada alamat \sphinxurl{http://localhost:8080/geoserver} sebagai WMS dan WFS, kemudian bandingkan perbedaan antara keduanya.







\renewcommand{\indexname}{Index}
\printindex
\end{document}